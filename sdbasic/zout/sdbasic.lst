			;-----------------------------------------------------------------------------
			; Aquarius+ SD BASIC system ROM
			;-----------------------------------------------------------------------------
			; By Frank van den Hoef
			;
			; Based on AQUBASIC source code by Bruce Abbott:
			; http://bhabbott.net.nz/micro_expander.html
			;
			; Modified from original Aquarius+ System ROM to work with soft ROM schema
			;
			; 
			; Useful links:
			; - Excellent Aquarius S2 ROM disassembly by Curtis F Kaylor:
			; https://github.com/RevCurtisP/Aquarius/blob/main/disassembly/aquarius-rom.lst
			;
			; Extra BASIC commands:
			; EDIT   - ** Not supported **
			; CLS    - Clear screen
			; LOCATE - Position on screen
			; OUT    - Output data to I/O port
			; PSG    - Program PSG register, value
			; DEBUG  - ** Not supported **
			; CALL   - Call machine code subroutine
			; LOAD   - Load file from USB disk
			; SAVE   - Save file to USB disk
			; DIR    - Display USB disk directory with wildcard
			; MKDIR  - Create directory
			; DEL    - Delete file
			; CD     - Change directory
			;
			; Extra BASIC functions:
			; IN()   - Get data from I/O port
			; JOY()  - Read joystick
			; HEX$() - Convert number to hexadecimal string
			;-----------------------------------------------------------------------------
			
			    include "regs.inc"
**** regs.inc ****
			;-----------------------------------------------------------------------------
			; regs.inc
			;
			; This file contains locations of hardware registers and ROM/RAM locations.
			;
			; Locations to the original Aquarius ROM are taken from the dissassembly by
			; Curtis F Kaylor, which can be found at:
			; https://github.com/RevCurtisP/Aquarius/blob/main/disassembly/aquarius-rom.lst
			;
			;-----------------------------------------------------------------------------
			
			;-----------------------------------------------------------------------------
			; System variables
			;-----------------------------------------------------------------------------
    -	3000          	SCREEN:     equ $3000   ; Screen Character Matrix
    -	3400          	COLOR:      equ $3400   ; Screen Color Matrix
    -	3800          	TTYPOS:     equ $3800   ; [M80] STORE TERMINAL POSITION HERE
    -	3801          	CURRAM:     equ $3801   ; Position in CHARACTER RAM of cursor
    -	3803          	USRPOK:     equ $3803   ; JP instruction for USR() routine
    -	3804          	USRADD:     equ $3804   ; Address of USR routine
    -	3806          	HOOK:       equ $3806   ; Extended ROM Hook Vector
    -	3808          	CNTOFL:     equ $3808   ; Line Counter. If not 0,
    -	3809          	LASTFF:     equ $3809   ; Last value last output to port #FF
    -	380A          	CHARC:      equ $380A   ; [M80] ISCNTC STORES EATEN CHAR HERE WHEN NOT A ^C
    -	380B          	RESPTR:     equ $380B   ; Pointer to Ctrl-Key Reserved Word
    -	380D          	CURCHR:     equ $380D   ; Character under Cursor
    -	380E          	LSTX:       equ $380E   ; [M64] Matrix Coordinate of Last Key Pressed
    -	380F          	KCOUNT:     equ $380F   ; Keyboard debounce counter
    -	3810          	FDIVC:      equ $3810   ;
    -	3814          	FDIVB:      equ $3814   ;
    -	3818          	FDIVA:      equ $3818   ;
    -	381B          	FDIVG:      equ $381B   ;
			;               $381E   ; {M80} RND FUNCTION PERTUBATION COUNT
    -	381F          	RNDCNT:     equ $381F   ;
			;               $3820   ;
    -	3821          	RNDTAB:     equ $3821   ; Unused Random Number TABLE
			                        ; The exact same table exists in CP/M Basic where it is unused
    -	3841          	RNDX:       equ $3841   ; [M80] LAST RANDOM NUMBER GENERATED, BETWEEN 0 AND 1
    -	3846          	LPTPOS:     equ $3846   ; [M80] POSITION OF LPT PRINT HEAD
    -	3847          	PRTFLG:     equ $3847   ; [M80] WHETHER OUTPUT GOES TO LPT
    -	3848          	LINLEN:     equ $3848   ; Length of a Screen Line
    -	3849          	CLMLST:     equ $3849   ;
    -	384A          	RUBSW:      equ $384A   ; [M80] RUBOUT SWITCH =1 INSIDE THE PROCESSING OF A RUBOUT (INLIN)
    -	384B          	TOPMEM:     equ $384B   ; [M80] TOP LOCATION TO USE FOR THE STACK INITIALLY SET UP BY INIT
			                        ; [M80] ACCORDING TO MEMORY SIZE TO ALLOW FOR 50 BYTES OF STRING SPACE.
			                        ; [M80] CHANGED BY A CLEAR COMMAND WITH AN ARGUMENT.
    -	384D          	CURLIN:     equ $384D   ; [M80] CURRENT LINE #
    -	384F          	TXTTAB:     equ $384F   ; [M80] POINTER TO BEGINNING OF TEXT
			                        ; [M80] DOESN'T CHANGE AFTER BEING SETUP BY INIT.
    -	3851          	FILNAM:     equ $3851   ; File Name for CSAVE and CLOAD
    -	3857          	FILNAF:     equ $3857   ; File Name Read from Cassette
    -	385D          	INSYNC:     equ $385D   ; Contains $FF between read of SYNC and data from tape
    -	385E          	CLFLAG:     equ $385E   ; Flags whether doing CLOAD (0) or CLOAD? ($FF)
    -	385F          	BUFMIN:     equ $385F   ; {M80} START OF BUFFER
    -	3860          	BUF:        equ $3860   ; [M80] TYPE IN STORED HERE. DIRECT STATEMENTS EXECUTE OUT OF HERE.
			                        ; [M80] REMEMBER "INPUT" SMASHES BUF. MUST BE AT A LOWER ADDRESS THAN DSCTMP
			                        ; [M80] OR ASSIGNMENT OF STRING VALUES IN DIRECT STATEMENTS WON'T COPY INTO
			                        ; [M80] STRING SPACE -- WHICH IT MUST ALLOW FOR SINGLE QUOTE IN BIG LINE
    -	38A9          	ENDBUF:     equ $38A9   ; [M80] PLACE TO STOP BIG LINES
    -	38AA          	DIMFLG:     equ $38AA   ; [M80] IN GETTING A POINTER TO A VARIABLE IT IS IMPORTANT TO REMEMBER
			                        ; [M80] WHETHER IT IS BEING DONE FOR "DIM" OR NOT
    -	38AB          	VALTYP:     equ $38AB   ; [M80] THE TYPE INDICATOR 0=NUMERIC 1=STRING
    -	38AC          	DORES:      equ $38AC   ; [M80] WHETHER CAN OR CAN'T CRUNCH RES'D WORDS TURNED ON WHEN "DATA"
			                        ; [M80] BEING SCANNED BY CRUNCH SO UNQUOTED STRINGS WON'T BE CRUNCHED.
    -	38AD          	MEMSIZ:     equ $38AD   ; [M80] HIGHEST LOCATION IN MEMORY
    -	38AF          	TEMPPT:     equ $38AF   ; [M80] POINTER AT FIRST FREE TEMP DESCRIPTOR. INITIALIZED TO POINT TO TEMPST
    -	38B1          	TEMPST:     equ $38B1   ; [M80] STORAGE FOR NUMTMP TEMP DESCRIPTORS
    -	38BD          	DSCTMP:     equ $38BD   ; [M80] STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
    -	38C1          	FRETOP:     equ $38C1   ; [M80] TOP OF STRING FREE SPACE
    -	38C3          	TENP3:      equ $38C3   ; [M80] USED MOMENTARILY BY FRMEVL. USED IN EXTENDED BY FOUT AND
			                        ; [M80] USER DEFINED FUNCTIONS ARRAY VARIABLE HANDLING TEMPORARY
    -	38C5          	TEMP8:      equ $38C5   ; [M80] USED TO STORE THE ADDRESS OF THE END OF STRING ARRAYS IN GARBAGE COLLECTION
    -	38C7          	ENDFOR:     equ $38C7   ; [M80] SAVED TEXT POINTER AT END OF "FOR" STATEMENT
    -	38C9          	DATLIN:     equ $38C9   ; [M80] DATA LINE # -- REMEMBER FOR ERRORS
    -	38CB          	SUBFLG:     equ $38CB   ; [M80] FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED "FOR" AND USER-DEFINED
			                        ; [M80] FUNCTION POINTER FETCHING TURN THIS ON BEFORE CALLING PTRGET SO
			                        ; [M80] ARRAYS WON'T BE DETECTED. STKINI AND PTRGET CLEAR IT.
    -	38CC          	USFLG:      equ $38CC   ; Direct Mode Flag
    -	38CD          	FLGINP:     equ $38CD   ; [M80] FLAGS WHETHER WE ARE DOING "INPUT" OR A READ
    -	38CE          	SAVTXT:     equ $38CE   ; [M80] PLACE WHERE NEWSTT SAVES TEXT POINTER
    -	38D0          	TENP2:      equ $38D0   ; [M80] FORMULA EVALUATOR TEMP MUST BE PRESERVED BY OPERATORS
			                        ; [M80] USED IN EXTENDED BY FOUT AND USER-DEFINED FUNCTIONS
    -	38D2          	OLDLIN:     equ $38D2   ; [M80] OLD LINE NUMBER (SETUP BY ^C,"STOP" OR "END" IN A PROGRAM)
    -	38D4          	OLDTXT:     equ $38D4   ; [M80] OLD TEXT POINTER
    -	38D6          	VARTAB:     equ $38D6   ; [M80] POINTER TO START OF SIMPLE VARIABLE SPACE. UPDATED WHENEVER
			                        ; [M80] THE SIZE OF THE PROGRAM CHANGES, SET TO [TXTTAB] BY SCRATCH ("NEW").
    -	38D8          	ARYTAB:     equ $38D8   ; [M80] POINTER TO BEGINNING OF ARRAY TABLE. INCREMENTED BY 6 WHENEVER
			                        ; [M80] A NEW SIMPLE VARIABLE IS FOUND, AND SET TO [VARTAB] BY CLEARC.
    -	38DA          	STREND:     equ $38DA   ; [M80] END OF STORAGE IN USE. INCREASED WHENEVER A NEW ARRAY
			                        ; [M80] OR SIMPLE VARIABLE IS ENCOUNTERED SET TO [VARTAB] BY CLEARC.
    -	38DC          	DATPTR:     equ $38DC   ; [M80] POINTER TO DATA. INITIALIZED TO POINT AT THE ZERO IN FRONT OF [TXTTAB]
			                        ; [M80] BY "DATPTR" WHICH IS CALLED BY CLEARC. UPDATED BY EXECUTION OF A "READ"
    -	38DE          	VARNAM:     equ $38DE
    -	38E0          	VARPNT:     equ $38E0
			;        $38E2:-$38E3   ; Unused
    -	38E4          	FACLO:      equ $38E4   ; [M80] LOW ORDER OF MANTISSA
    -	38E5          	FACMO:      equ $38E5   ; [M80] MIDDLE ORDER OF MANTISSA
    -	38E6          	FACHO:      equ $38E6   ; [M80] HIGH ORDER OF MANTISSA
    -	38E7          	FAC:        equ $38E7   ; [M80] EXPONENT
    -	38E8          	FBUFFR:     equ $38E8   ; [M80[ BUFFER FOR FOUT
    -	38F6          	RESHO:      equ $38F6   ; [M65] RESULT OF MULTIPLIER AND DIVIDER
    -	38F7          	RESMO:      equ $38F7   ; RESMO and RESLO are loaded into and stored from HL
    -	38F8          	RESLO:      equ $38F8   ;
    -	38F9          	SAVSTK:     equ $38F9   ; [M80] NEWSTT SAVES STACK HERE BEFORE SO THAT ERROR REVERY CAN
			                        ; [M80] CAN DATPTR THE STACK WHEN AN ERROR OCCURS
			;               $3900   ; This is always 0
    -	3901          	BASTXT:     equ $3901   ; Start of Basic Program
			
			;-----------------------------------------------------------------------------
			; Variables
			;-----------------------------------------------------------------------------
    -	BEFF          	BASIC_RAM_END: equ $BEFF    ; End of BASIC RAM, $BF00-$BFFF is reserved for our extensions
			
    -	BF00          	PATHLEN:    equ $BF00   ; Length byte
    -	BF01          	PATHBUF:    equ $BF01   ; Path buffer
    -	BFEC          	TMPBUF:     equ $BFEC   ; 16-byte temporary buffer
    -	BFFC          	BINSTART:   equ $BFFC   ; binary file load/save address
    -	BFFE          	BINLEN:     equ $BFFE   ; 16-bit binary file length
			
			;-----------------------------------------------------------------------------
			; System ROM functions
			;-----------------------------------------------------------------------------
    -	0153          	INITFF:     equ $0153   ; Initialize I/O Port 255
    -	03C4          	SNERR:      equ $03C4   ; Syntax error
    -	03D6          	MOERR:      equ $03D6   ; Missing Operand error
    -	03DB          	ERROR:      equ $03DB   ; Process error code, E = code (offset to 2 char error name)
    -	03F4          	ERRFN1:     equ $03F4
    -	0402          	READY:      equ $0402
    -	05A8          	RESSRC:     equ $05A8
    -	062C          	NEWSTT:     equ $062C
    -	0682          	FRCINT:     equ $0682   ; Convert fp number to 16 bit signed integer in DE
    -	0697          	FCERR:      equ $0697   ; Function call error
    -	06DB          	RUNC2:      equ $06DB
    -	0972          	FRMNUM:     equ $0972   ; Evaluate numeric expression
    -	0975          	CHKNUM:     equ $0975   ; Error if evaluated expression not a number
    -	0976          	CHKSTR:     equ $0976   ; Error if evaluated expression not string
    -	0985          	FRMEVL:     equ $0985   ; Evaluate formula
    -	0A37          	PARCHK:     equ $0A37   ; Evaluate expression in brackets
    -	0A49          	LABBCK:     equ $0A49
    -	0B36          	SNGFLT:     equ $0B36   ; Store variable 8 bit (out: B = value)
    -	0B54          	GETBYT:     equ $0B54   ; Evaluate numeric expression (integer 0-255)
    -	0BB7          	OMERR:      equ $0BB7   ; Out of memory error
    -	0BBE          	SCRTCH:     equ $0BBE
    -	0BCB          	RUNC:       equ $0BCB
    -	0BCF          	CLEARC:     equ $0BCF
    -	0BE5          	STKINI:     equ $0BE5
    -	0E9D          	STROUT:     equ $0E9D   ; Print null-terminated string in HL
    -	0FF7          	LEN1:       equ $0FF7   ; Get string length (in: (FPREG) = string block, out: HL = string block, A = length)
    -	10D1          	PTRGET:     equ $10D1   ; Get variable (out: BC = addr, DE = len)
    -	19EA          	CRDO:       equ $19EA   ; Print CR+LF
    -	1A40          	WRMCON:     equ $1A40
    -	1D72          	TTYCHR:     equ $1D72   ; Print character in A with pause/break at end of page
    -	1D94          	TTYOUT:     equ $1D94   ; Print character in A
    -	1DE7          	TTYFIS:     equ $1DE7   ; Save Column and Position
    -	1FE1          	JMPINI:     equ $1FE1   ; Power Up/Reset Routine: Jumped to from RST 0
    -	1FF2          	PRNTIT:     equ $1FF2   ; Print copyright message and return
			
			; Extra variables / functions
    -	1679          	INT2STR:    equ $1679   ; Convert 16 bit integer in HL to text at FPSTR (starts with ' ')
    -	38E9          	FPSTR:      equ $38E9   ; Floating point string
			
    -	E010          	XINIT:      equ $E010   ; Cartridge entry point
    -	0089          	RESET:      equ $0089
			
			;-----------------------------------------------------------------------------
			; IO registers
			;-----------------------------------------------------------------------------
    -	00E0          	IO_VCTRL:       equ $E0
    -	00E1          	IO_VSCRX_L:     equ $E1
    -	00E2          	IO_VSCRX_H:     equ $E2
    -	00E3          	IO_VSCRY:       equ $E3
    -	00E4          	IO_VSPRSEL:     equ $E4
    -	00E5          	IO_VSPRX_L:     equ $E5
    -	00E6          	IO_VSPRX_H:     equ $E6
    -	00E7          	IO_VSPRY:       equ $E7
    -	00E8          	IO_VSPRIDX:     equ $E8
    -	00E9          	IO_VSPRATTR:    equ $E9
    -	00EA          	IO_VPALSEL:     equ $EA
    -	00EB          	IO_VPALDATA:    equ $EB
    -	00EC          	IO_VLINE:       equ $EC
    -	00ED          	IO_VIRQLINE:    equ $ED
    -	00EE          	IO_IRQMASK:     equ $EE
    -	00EF          	IO_IRQSTAT:     equ $EF
    -	00F0          	IO_BANK0:       equ $F0
    -	00F1          	IO_BANK1:       equ $F1
    -	00F2          	IO_BANK2:       equ $F2
    -	00F3          	IO_BANK3:       equ $F3
    -	00F4          	IO_ESPCTRL:     equ $F4
    -	00F5          	IO_ESPDATA:     equ $F5
    -	00F6          	IO_PSG1DATA:    equ $F6
    -	00F7          	IO_PSG1ADDR:    equ $F7
    -	00F8          	IO_PSG2DATA:    equ $F8
    -	00F9          	IO_PSG2ADDR:    equ $F9
    -	00FB          	IO_SYSCTRL:     equ $FB
    -	00FC          	IO_CASSETTE:    equ $FC
    -	00FD          	IO_CPM:         equ $FD     ; Write-only
    -	00FD          	IO_VSYNC:       equ $FD     ; Read-only
    -	00FE          	IO_PRINTER:     equ $FE
    -	00FF          	IO_SCRAMBLE:    equ $FF     ; Write-only
    -	00FF          	IO_KEYBOARD:    equ $FF     ; Read-only
			
    -	0001          	VCTRL_TEXT_EN:   equ (1<<0)
    -	0000          	VCTRL_MODE_OFF:  equ (0<<1)
    -	0002          	VCTRL_MODE_TILE: equ (1<<1)
    -	0004          	VCTRL_MODE_BM:   equ (2<<1)
    -	0008          	VCTRL_SPR_EN:    equ (1<<3)
    -	0010          	VCTRL_TEXT_PRIO: equ (1<<4)
			
			;-----------------------------------------------------------------------------
			; Other definitions
			;-----------------------------------------------------------------------------
    -	0000          	BANK0_BASE: equ $0000
    -	4000          	BANK1_BASE: equ $4000
    -	8000          	BANK2_BASE: equ $8000
    -	C000          	BANK3_BASE: equ $C000
			
    -	0080          	BANK_READONLY:  equ $80     ; Bank readonly
    -	0040          	BANK_OVERLAY:   equ $40     ; RAM overlay
			
			;-----------------------------------------------------------------------------
			; Other definitions
			;-----------------------------------------------------------------------------
			SYNCHK macro value
			    rst     $08
			    db      'value'
			endm
			
			OUTCHR macro
			    rst     $18
			endm
			
			;-----------------------------------------------------------------------------
			; ESP32 commands
			;-----------------------------------------------------------------------------
    -	0001          	ESPCMD_RESET:      equ $01     ; Reset ESP
    -	0002          	ESPCMD_VERSION:    equ $02     ; Get version string
    -	0010          	ESPCMD_OPEN:       equ $10     ; Open / create file
    -	0011          	ESPCMD_CLOSE:      equ $11     ; Close open file
    -	0012          	ESPCMD_READ:       equ $12     ; Read from file
    -	0013          	ESPCMD_WRITE:      equ $13     ; Write to file
    -	0014          	ESPCMD_SEEK:       equ $14     ; Move read/write pointer
    -	0015          	ESPCMD_TELL:       equ $15     ; Get current read/write
    -	0016          	ESPCMD_OPENDIR:    equ $16     ; Open directory
    -	0017          	ESPCMD_CLOSEDIR:   equ $17     ; Close open directory
    -	0018          	ESPCMD_READDIR:    equ $18     ; Read from directory
    -	0019          	ESPCMD_DELETE:     equ $19     ; Remove file or directory
    -	001A          	ESPCMD_RENAME:     equ $1A     ; Rename / move file or directory
    -	001B          	ESPCMD_MKDIR:      equ $1B     ; Create directory
    -	001C          	ESPCMD_CHDIR:      equ $1C     ; Change directory
    -	001D          	ESPCMD_STAT:       equ $1D     ; Get file status
    -	001E          	ESPCMD_GETCWD:     equ $1E     ; Get current working directory
    -	001F          	ESPCMD_CLOSEALL:   equ $1F     ; Close any open file/directory descriptor
			
    -	FFFF          	ERR_NOT_FOUND:     equ -1   ; File / directory not found
    -	FFFE          	ERR_TOO_MANY_OPEN: equ -2   ; Too many open files / directories
    -	FFFD          	ERR_PARAM:         equ -3   ; Invalid parameter
    -	FFFC          	ERR_EOF:           equ -4   ; End of file / directory
    -	FFFB          	ERR_EXISTS:        equ -5   ; File already exists
    -	FFFA          	ERR_OTHER:         equ -6   ; Other error
    -	FFF9          	ERR_NO_DISK:       equ -7   ; No disk
    -	FFF8          	ERR_NOT_EMPTY:     equ -8   ; Not empty
			
    -	0000          	FO_RDONLY:      equ 0x00    ; Open for reading only
    -	0001          	FO_WRONLY:      equ 0x01    ; Open for writing only
    -	0002          	FO_RDWR:        equ 0x02    ; Open for reading and writing
    -	0003          	FO_ACCMODE:     equ 0x03    ; Mask for above modes
    -	0004          	FO_APPEND:      equ 0x04    ; Append mode
    -	0008          	FO_CREATE:      equ 0x08    ; Create if non-existant
    -	0010          	FO_TRUNC:       equ 0x10    ; Truncate to zero length
    -	0020          	FO_EXCL:        equ 0x20    ; Error if already exists
**** sdbasic.asm ****
			
    -	2000          	    org     $2000
   0+10	2000  C30920  	    jp      _reset          ; Called from main ROM at reset vector
  10+10	2003  C37F20  	    jp      _coldboot       ; Called from main ROM for cold boot
  20+10	2006  C3EB20  	    jp      _start_cart
			
			;-----------------------------------------------------------------------------
			; Reset vector
			;
			; CAUTION: stack isn't available at this point, so don't use any instruction
			;          that uses the stack.
			;-----------------------------------------------------------------------------
    -	2009          	_reset:
			    ; Set up temp stack in text line buffer
  30+10	2009  31A038  	    ld      sp, $38A0
			
			    ; Initialize banking registers
  40+7	200C  3EFC    	    ld      a, 60 | BANK_OVERLAY | BANK_READONLY
  47+11	200E  D3F0    	    out     (IO_BANK0), a
  58+7	2010  3E39    	    ld      a, 57
  65+11	2012  D3F1    	    out     (IO_BANK1), a
  76+7	2014  3E3A    	    ld      a, 58
  83+11	2016  D3F2    	    out     (IO_BANK2), a
  94+7	2018  3E3B    	    ld      a, 59
 101+11	201A  D3F3    	    out     (IO_BANK3), a
			
			    ; Init video mode
 112+7	201C  3E01    	    ld      a, 1
 119+11	201E  D3E0    	    out     (IO_VCTRL), a
			
			    ; Init palette 0
 130+10	2020  213E20  	    ld      hl, .default_palette
 140+7	2023  0EEA    	    ld      c, IO_VPALSEL
 147+7	2025  0600    	    ld      b, 0
 154+7	2027  1620    	    ld      d, 32
    -	2029          	.palloop:
 161+12	2029  ED41    	    out     (c), b
 173+7	202B  7E      	    ld      a, (hl)
 180+11	202C  D3EB    	    out     (IO_VPALDATA), a
 191+6	202E  23      	    inc     hl
 197+4	202F  04      	    inc     b
 201+4	2030  15      	    dec     d
 205+7+5	2031  20F6    	    jr      nz, .palloop
			
			    ; Initialize character RAM
 212+17	2033  CD5E20  	    call    init_charram
			
			    ; Initialize ESP
 229+7	2036  3E01    	    ld      a, ESPCMD_RESET
 236+17	2038  CD0726  	    call    esp_cmd
			
			    ; Back to system ROM init
 253+10	203B  C3E11F  	    jp      JMPINI
			
    -	203E          	.default_palette:
    -	203E  1101110F	    dw $111, $F11, $1F1, $FF1, $22E, $F1F, $3CC, $FFF
              F101F10F
              2E021F0F
              CC03FF0F
    -	204E  CC0CBB03	    dw $CCC, $3BB, $C2C, $419, $FF7, $2D4, $B22, $333
              2C0C1904
              F70FD402
              220B3303
			
			;-----------------------------------------------------------------------------
			; Character RAM initialization
			;-----------------------------------------------------------------------------
    -	205E          	init_charram:
 263+10	205E  C9      	    ret   ; Initialized by boot.bin
			    
			    ; Save current bank 1/2
 273+11	205F  DBF1    	    in      a, (IO_BANK1)
 284+11	2061  F5      	    push    a
 295+11	2062  DBF2    	    in      a, (IO_BANK2)
 306+11	2064  F5      	    push    a
			
			    ; Temporarily set up mappings for character RAM and character ROM
 317+7	2065  3E15    	    ld      a, 21           ; Page 21: character RAM
 324+11	2067  D3F1    	    out     (IO_BANK1), a
 335+7	2069  3E3C    	    ld      a, 60           ; Page 60: Soft ROM
 342+11	206B  D3F2    	    out     (IO_BANK2), a
			
			    ; Copy character ROM to character RAM
 353+10	206D  110040  	    ld      de, BANK1_BASE
 363+10	2070  2100B0  	    ld      hl, BANK2_BASE + $3000
 373+10	2073  010008  	    ld      bc, 2048
 383+16+5	2076  EDB0    	    ldir
			
			    ; Restore bank 1/2
 399+10	2078  F1      	    pop     a
 409+11	2079  D3F2    	    out     (IO_BANK2), a
 420+10	207B  F1      	    pop     a
 430+11	207C  D3F1    	    out     (IO_BANK1), a
 441+10	207E  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Cold boot entry point
			;-----------------------------------------------------------------------------
    -	207F          	_coldboot:
			    ; Set memory size
 451+10	207F  21FFBE  	    ld      hl, BASIC_RAM_END   ; Top of public RAM
 461+16	2082  22AD38  	    ld      (MEMSIZ), hl        ; MEMSIZ, Contains the highest RAM location
 477+10	2085  1100FC  	    ld      de, -1024           ; Subtract 1k for strings space
 487+11	2088  19      	    add     hl, de
 498+16	2089  224B38  	    ld      (TOPMEM), hl        ; TOPMEM, Top location to be used for stack
 514+10	208C  210039  	    ld      hl, BASTXT-1
 524+10	208F  3600    	    ld      (hl), $00           ; NULL at start of BASIC program
 534+6	2091  23      	    inc     hl
 540+16	2092  224F38  	    ld      (TXTTAB), hl        ; Beginning of BASIC program text
 556+17	2095  CDBE0B  	    call    SCRTCH              ; ST_NEW2 - NEW without syntax check
			
			    ; Install BASIC HOOK
 573+10	2098  210921  	    ld      hl, hook_handler
 583+16	209B  220638  	    ld      (HOOK), hl
			
			    ; Show our copyright message
 599+17	209E  CDF21F  	    call    PRNTIT              ; Print copyright string in ROM
 616+10	20A1  21C920  	    ld      hl, .str_system     ; Print ROM version
 626+17	20A4  CD9D0E  	    call    STROUT
 643+7	20A7  3E02    	    ld      a, ESPCMD_VERSION
 650+17	20A9  CD0726  	    call    esp_cmd
    -	20AC          	.print_version:
 667+17	20AC  CD1A26  	    call    esp_get_byte
 684+4	20AF  B7      	    or      a
 688+7+5	20B0  2805    	    jr      z, .print_done
 695+17	20B2  CD721D  	    call    TTYCHR
 712+12	20B5  18F5    	    jr      .print_version
			
    -	20B7          	.print_done:
 724+17	20B7  CDEA19  	    call    CRDO
 741+10	20BA  21DD20  	    ld      hl, .str_basic      ; Print ROM version
 751+17	20BD  CD9D0E  	    call    STROUT
 768+17	20C0  CDEA19  	    call    CRDO
 785+17	20C3  CDEA19  	    call    CRDO
			
 802+10	20C6  C35301  	    jp      INITFF              ; Continue in ROM
			
    -	20C9          	.str_system:
    -	20C9  0D0A    	    db $0D, $0A
    -	20CB  41717561	    db "Aquarius+ System ",0
              72697573
              2B205379
              7374656D
              2000
    -	20DD          	.str_basic:
    -	20DD  53442D42	    db "SD-BASIC "
              41534943
              20
    -	20E6          	.ver_basic:
    -	20E6  76312E30	    db "v1.0",0
              00
			
			;-----------------------------------------------------------------------------
			; Cartridge start entry point - A hold scramble value
			;-----------------------------------------------------------------------------
    -	20EB          	_start_cart:
 812+7	20EB  FE00    	    cp      $00
 819+10	20ED  C2F320  	    jp      nz, .descramble
 829+10	20F0  C310E0  	    jp      XINIT
			
    -	20F3          	.descramble:
			    ; Map destination RAM in bank2
 839+7	20F3  3E3F    	    ld      a, 63
 846+11	20F5  D3F2    	    out     (IO_BANK2), a
			
			    ; Copy ROM cartridge to RAM
 857+10	20F7  110080  	    ld      de, $8000
 867+10	20FA  2100C0  	    ld      hl, $C000
 877+10	20FD  010040  	    ld      bc, $4000
 887+16+5	2100  EDB0    	    ldir
			
			    ; Map RAM in bank3
 903+7	2102  3E3F    	    ld      a, 63
 910+11	2104  D3F3    	    out     (IO_BANK3), a
			
			    ; Descramble and start ROM
 921+10	2106  C31129  	    jp      descramble_rom
			
			;-----------------------------------------------------------------------------
			; Hook handler
			;-----------------------------------------------------------------------------
    -	2109          	hook_handler:
			    ; The hook index byte is stored after the RST $30 call. So SP currently
			    ; points to this hook index byte. Retrieve the hook index byte into A
			    ; and determine the correct return address.
 931+19	2109  E3      	    ex      (sp), hl            ; Save HL and get address of byte after RST $30
 950+11	210A  F5      	    push    af                  ; Save AF
 961+7	210B  7E      	    ld      a, (hl)             ; A = byte (RST $30 parameter)
 968+6	210C  23      	    inc     hl                  ; Skip over byte after RST $30
 974+11	210D  E5      	    push    hl                  ; Push return address
			
			    ; Find index in hook indexes table
 985+10	210E  212B21  	    ld      hl, _hook_idxs
 995+11	2111  C5      	    push    bc
1006+10	2112  010600  	    ld      bc, _hook_handlers - _hook_idxs + 1
1016+16+5	2115  EDB1    	    cpir                        ; Find parameter in list
1032+4	2117  79      	    ld      a, c                ; A = parameter number in list
1036+10	2118  C1      	    pop     bc
			
			    ; Call handler from hook handlers table
1046+4	2119  87      	    add     a, a                ; A * 2 to index WORD size vectors
1050+10	211A  213021  	    ld      hl, _hook_handlers
    -	211D          	do_jump:
1060+4	211D  85      	    add     a, l
1064+4	211E  6F      	    ld      l, a
1068+4	211F  AF      	    xor     a
1072+4	2120  8C      	    adc     a, h
1076+4	2121  67      	    ld      h, a                ; HL += vector number
1080+7	2122  7E      	    ld      a, (hl)
1087+6	2123  23      	    inc     hl
1093+7	2124  66      	    ld      h, (hl)             ; Get vector address
1100+4	2125  6F      	    ld      l, a
1104+4	2126  E9      	    jp      (hl)                ; And jump to it will return to hook_exit
			
			; End of hook handler
    -	2127          	hook_exit:
1108+10	2127  E1      	    pop     hl                  ; Get return address
1118+10	2128  F1      	    pop     af                  ; Restore AF
1128+19	2129  E3      	    ex      (sp), hl            ; Restore HL and set return address
1147+10	212A  C9      	    ret                         ; Return to code after RST $30,xx
			
			; Hook indexes we're handling
			; NOTE: order is reverse of hook handlers table!
    -	212B          	_hook_idxs:  ; xx      index caller            @addr  performing function:
    -	212B  18      	    db      24      ; 5   RUN                 $06BE  starting BASIC program
    -	212C  17      	    db      23      ; 4   exec_next_statement $0658  interpreting next BASIC statement
    -	212D  16      	    db      22      ; 3   token_to_keyword    $05A0  expanding token to keyword
    -	212E  0A      	    db      10      ; 2   keyword_to_token    $0536  converting keyword to token
    -	212F  1B      	    db      27      ; 1   FUNCTIONS           $0A5F  executing a function
			
			; Hook handler entry points
    -	2130          	_hook_handlers:
    -	2130  2721    	    dw      hook_exit           ; 0 parameter not found in list
    -	2132  9721    	    dw      execute_function    ; 1 executing a function
    -	2134  AB21    	    dw      keyword_to_token    ; 2 converting keyword to token
    -	2136  BE21    	    dw      token_to_keyword    ; 3 expanding token to keyword
    -	2138  D021    	    dw      exec_next_statement ; 4 execute next BASIC statement
    -	213A  EC21    	    dw      run_cmd             ; 5 run program
			
			;-----------------------------------------------------------------------------
			; Our commands and functions
			;-----------------------------------------------------------------------------
    -	00D4          	BTOKEN:     equ $D4             ; Our first token number
			
    -	213C          	TBLCMDS:
    -	213C  C5      	    db $80 + 'E'
    -	213D  444954  	    db "DIT"
    -	2140  C3      	    db $80 + 'C'
    -	2141  4C53    	    db "LS"
    -	2143  CC      	    db $80 + 'L'
    -	2144  4F434154	    db "OCATE"
              45
    -	2149  CF      	    db $80 + 'O'
    -	214A  5554    	    db "UT"
    -	214C  D0      	    db $80 + 'P'
    -	214D  5347    	    db "SG"
    -	214F  C4      	    db $80 + 'D'
    -	2150  45425547	    db "EBUG"
    -	2154  C3      	    db $80 + 'C'
    -	2155  414C4C  	    db "ALL"
    -	2158  CC      	    db $80 + 'L'
    -	2159  4F4144  	    db "OAD"
    -	215C  D3      	    db $80 + 'S'
    -	215D  415645  	    db "AVE"
    -	2160  C4      	    db $80 + 'D'
    -	2161  4952    	    db "IR"
    -	2163  CD      	    db $80 + 'M'
    -	2164  4B444952	    db "KDIR"
    -	2168  C4      	    db $80 + 'D'
    -	2169  454C    	    db "EL"
    -	216B  C3      	    db $80 + 'C'
    -	216C  44      	    db "D"
			
			    ; Functions
    -	216D  C9      	    db $80 + 'I'
    -	216E  4E      	    db "N"
    -	216F  CA      	    db $80 + 'J'
    -	2170  4F59    	    db "OY"
    -	2172  C8      	    db $80 + 'H'
    -	2173  455824  	    db "EX$"
    -	2176  80      	    db $80             ; End of table marker
			
    -	2177          	TBLJMPS:
    -	2177  0722    	    dw ST_reserved     ; Previously EDIT
    -	2179  0822    	    dw ST_CLS
    -	217B  1C22    	    dw ST_LOCATE
    -	217D  0C22    	    dw ST_OUT
    -	217F  5B22    	    dw ST_PSG
    -	2181  0722    	    dw ST_reserved     ; Previously DEBUG
    -	2183  1423    	    dw ST_CALL
    -	2185  1C23    	    dw ST_LOAD
    -	2187  6B23    	    dw ST_SAVE
    -	2189  F623    	    dw ST_DIR
    -	218B  E523    	    dw ST_MKDIR
    -	218D  A623    	    dw ST_DEL          ; Previously KILL
    -	218F  B723    	    dw ST_CD
    -	2191          	TBLJEND:
			
    -	000D          	BCOUNT: equ (TBLJEND - TBLJMPS) / 2     ; Number of commands
			
    -	2191          	TBLFNJP:
    -	2191  8422    	    dw      FN_IN
    -	2193  9822    	    dw      FN_JOY
    -	2195  DA22    	    dw      FN_HEX
    -	2197          	TBLFEND:
			
    -	0003          	FCOUNT: equ (TBLFEND - TBLFNJP) / 2  ; Number of functions
			
    -	00E1          	firstf: equ BTOKEN + BCOUNT          ; Token number of first function in table
    -	00E3          	lastf:  equ firstf + FCOUNT - 1      ; Token number of last function in table
			
			;-----------------------------------------------------------------------------
			; BASIC Function handler - hook 27
			;-----------------------------------------------------------------------------
			; called from $0a5f by RST $30,$1b
			;
    -	2197          	execute_function:
1157+10	2197  C1      	    pop     bc                  ; Get return address
1167+10	2198  F1      	    pop     af
1177+10	2199  E1      	    pop     hl
1187+11	219A  C5      	    push    bc                  ; Push return address back on stack
1198+7	219B  FE2F    	    cp      firstf - $B2        ; ($B2 = first system BASIC function token)
1205+5+6	219D  D8      	    ret     c                   ; Return if function number below ours
1210+7	219E  FE32    	    cp      lastf - $B2 + 1
1217+5+6	21A0  D0      	    ret     nc                  ; Return if function number above ours
1222+7	21A1  D62F    	    sub     firstf - $B2
1229+4	21A3  87      	    add     a, a                ; Index = A * 2
1233+11	21A4  E5      	    push    hl
1244+10	21A5  219121  	    ld      hl, TBLFNJP         ; Function address table
1254+10	21A8  C31D21  	    jp      do_jump             ; JP to our function
			
			;-----------------------------------------------------------------------------
			; Convert keyword to token - hook 10
			;-----------------------------------------------------------------------------
    -	21AB          	keyword_to_token:
1264+4	21AB  78      	    ld      a, b               ; A = current index
			
1268+7	21AC  FECB    	    cp      $CB                ; If < $CB then keyword was found in BASIC table
1275+10	21AE  C22721  	    jp      nz, hook_exit       ;    so return
			
1285+10	21B1  C1      	    pop     bc                 ; Get return address from stack
1295+10	21B2  F1      	    pop     af                 ; Restore AF
1305+10	21B3  E1      	    pop     hl                 ; Restore HL
1315+11	21B4  C5      	    push    bc                 ; Put return address back onto stack
			
			    ; Set our own keyword table and let BASIC code use that instead
1326+4	21B5  EB      	    ex      de, hl             ; HL = Line buffer
1330+10	21B6  113B21  	    ld      de, TBLCMDS - 1    ; DE = our keyword table
1340+7	21B9  06D3    	    ld      b, BTOKEN - 1      ; B = our first token
1347+10	21BB  C3F904  	    jp      $04F9              ; Continue searching using our keyword table
			
			;-----------------------------------------------------------------------------
			; Convert token to keyword - hook 22
			;
			; This function will check if the passed token is one of the stock BASIC or
			; our extra commands. If it one of our commands, we pass our command table
			; to the ROM code.
			;-----------------------------------------------------------------------------
    -	21BE          	token_to_keyword:
1357+10	21BE  D1      	    pop     de
1367+10	21BF  F1      	    pop     af                  ; Restore AF (token)
1377+10	21C0  E1      	    pop     hl                  ; Restore HL (BASIC text)
1387+7	21C1  FED4    	    cp      BTOKEN              ; Is it one of our tokens?
1394+7+5	21C3  3002    	    jr      nc, .expand_token   ; Yes, expand it
1401+11	21C5  D5      	    push    de
1412+10	21C6  C9      	    ret                         ; No, return to system for expansion
			
    -	21C7          	.expand_token:
1422+7	21C7  D6D3    	    sub     BTOKEN - 1
1429+4	21C9  4F      	    ld      c, a                ; C = offset to AquBASIC command
1433+10	21CA  113C21  	    ld      de, TBLCMDS         ; DE = table of AquBASIC command names
1443+10	21CD  C3A805  	    jp      RESSRC              ; Print keyword indexed by C
			
			;-----------------------------------------------------------------------------
			; exec_next_statement - hook 23
			;-----------------------------------------------------------------------------
    -	21D0          	exec_next_statement:
1453+10	21D0  C1      	    pop     bc                  ; BC = return address
1463+10	21D1  F1      	    pop     af                  ; AF = token, flags
1473+10	21D2  E1      	    pop     hl                  ; HL = text
1483+7+5	21D3  3002    	    jr      nc, .process        ; if NC then process BASIC statement
1490+11	21D5  C5      	    push    bc
1501+10	21D6  C9      	    ret                         ; else return to system
			
    -	21D7          	.process:
			    ; Check if the token is own of our own, otherwise give syntax error
1511+7	21D7  D654    	    sub     (BTOKEN) - $80
1518+10	21D9  DAC403  	    jp      c, SNERR           ; SN error if < our 1st BASIC command token
1528+7	21DC  FE0D    	    cp      BCOUNT              ; Count number of commands
1535+10	21DE  D2C403  	    jp      nc, SNERR          ; SN error if > out last BASIC command token
			
			    ; Execute handler 
1545+4	21E1  07      	    rlca                        ; A*2 indexing WORDs
1549+4	21E2  4F      	    ld      c, a
1553+7	21E3  0600    	    ld      b, $00              ; BC = index
1560+4	21E5  EB      	    ex      de, hl
1564+10	21E6  217721  	    ld      hl, TBLJMPS         ; HL = our command jump table
1574+10	21E9  C36506  	    jp      $0665               ; Continue with exec_next_statement
			
			;-----------------------------------------------------------------------------
			; RUN command - hook 24
			;-----------------------------------------------------------------------------
    -	21EC          	run_cmd:
1584+10	21EC  F1      	    pop     af                 ; Clean up stack
1594+10	21ED  F1      	    pop     af                 ; Restore AF
1604+10	21EE  E1      	    pop     hl                 ; Restore HL
1614+10	21EF  CACB0B  	    jp      z, RUNC            ; If no argument then RUN from 1st line
			
1624+11	21F2  E5      	    push    hl
1635+17	21F3  CD8509  	    call    FRMEVL             ; Get argument type
1652+10	21F6  E1      	    pop     hl
			
1662+13	21F7  3AAB38  	    ld      a, (VALTYP)
1675+4	21FA  3D      	    dec     a                  ; 0 = string
1679+10	21FB  CABD28  	    jp      z, run_file
			
			    ; RUN with line number
1689+17	21FE  CDCF0B  	    call    CLEARC             ; Init BASIC run environment
1706+10	2201  012C06  	    ld      bc, NEWSTT
1716+10	2204  C3DB06  	    jp      RUNC2              ; GOTO line number
			
			;-----------------------------------------------------------------------------
			; Not implemented statement - do nothing
			;-----------------------------------------------------------------------------
    -	2207          	ST_reserved:
1726+10	2207  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; CLS statement
			;-----------------------------------------------------------------------------
    -	2208          	ST_CLS:
			    ; Clear screen
1736+7	2208  3E0B    	    ld      a, 11
1743+11	220A  DF      	    OUTCHR
1754+10	220B  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; OUT statement
			; syntax: OUT port, data
			;-----------------------------------------------------------------------------
    -	220C          	ST_OUT:
1764+17	220C  CD7209  	    call    FRMNUM              ; Get/evaluate port
1781+17	220F  CD8206  	    call    FRCINT              ; Convert number to 16 bit integer (result in DE)
1798+11	2212  D5      	    push    de                  ; Stored to be used in BC
			
			    ; Expect comma
1809+11	2213  CF2C    	    SYNCHK  ","
			
1820+17	2215  CD540B  	    call    GETBYT              ; Get/evaluate data
1837+10	2218  C1      	    pop     bc                  ; BC = port
1847+12	2219  ED79    	    out     (c), a              ; Out data to port
1859+10	221B  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; LOCATE statement
			; Syntax: LOCATE col, row
			;-----------------------------------------------------------------------------
    -	221C          	ST_LOCATE:
1869+17	221C  CD540B  	    call    GETBYT              ; Read number from command line (column). Stored in A and E
1886+11	221F  F5      	    push    af                  ; Column store on stack for later use
1897+4	2220  3D      	    dec     a
1901+7	2221  FE26    	    cp      38                  ; Compare with 38 decimal (max cols on screen)
1908+10	2223  D29706  	    jp      nc, FCERR           ; If higher then 38 goto FC error
			
			    ; Expect comma
1918+11	2226  CF2C    	    SYNCHK  ','
			
1929+17	2228  CD540B  	    call    GETBYT              ; Read number from command line (row). Stored in A and E
1946+7	222B  FE18    	    cp      $18                 ; Compare with 24 decimal (max rows on screen)
1953+10	222D  D29706  	    jp      nc,FCERR            ; If higher then 24 goto FC error
			
1963+4	2230  1C      	    inc     e
1967+10	2231  F1      	    pop     af                  ; Restore column from store
1977+4	2232  57      	    ld      d, a                ; Column in register D, row in register E
1981+4	2233  EB      	    ex      de, hl              ; Switch DE with HL
1985+17	2234  CD3922  	    call    .goto_hl            ; Cursor to screen location HL (H=col, L=row)
2002+4	2237  EB      	    ex      de, hl
2006+10	2238  C9      	    ret
			
    -	2239          	.goto_hl:
2016+11	2239  F5      	    push    af
			
			    ; Restore character behind cursor
2027+11	223A  E5      	    push    hl
2038+4	223B  D9      	    exx
2042+16	223C  2A0138  	    ld      hl, (CURRAM)        ; CHRPOS - address of cursor within matrix
2058+13	223F  3A0D38  	    ld      a, (CURCHR)         ; BUFO - storage of the character behind the cursor
2071+7	2242  77      	    ld      (hl), a             ; Put original character on screen
2078+10	2243  E1      	    pop     hl
			
			    ; Calculate new cursor location
2088+4	2244  7D      	    ld      a, l
2092+4	2245  87      	    add     a, a
2096+4	2246  87      	    add     a, a
2100+4	2247  85      	    add     a, l
2104+4	2248  EB      	    ex      de, hl
2108+4	2249  5A      	    ld      e, d
2112+7	224A  1600    	    ld      d, $00
2119+4	224C  62      	    ld      h, d
2123+4	224D  6F      	    ld      l, a
2127+4	224E  7B      	    ld      a, e
2131+4	224F  3D      	    dec     a
2135+11	2250  29      	    add     hl, hl
2146+11	2251  29      	    add     hl, hl
2157+11	2252  29      	    add     hl, hl              ; HL is now 40 * rows
2168+11	2253  19      	    add     hl, de              ; Added the columns
2179+10	2254  110030  	    ld      de, SCREEN          ; Screen character-matrix (= 12288 dec)
2189+11	2257  19      	    add     hl, de              ; Putting it all together
2200+10	2258  C3E71D  	    jp      TTYFIS              ; Save cursor position and return
			
			;-----------------------------------------------------------------------------
			; PSG statement
			; syntax: PSG register, value [, ... ]
			;-----------------------------------------------------------------------------
    -	225B          	ST_PSG:
2210+7	225B  FE00    	    cp      $00
2217+10	225D  CAD603  	    jp      z, MOERR         ; MO error if no args
			
    -	2260          	.psgloop:
			    ; Get PSG register to write to
2227+17	2260  CD540B  	    call    GETBYT           ; Get/evaluate register
2244+7	2263  FE10    	    cp      16
2251+7+5	2265  3010    	    jr      nc, .psg2
			
2258+11	2267  D3F7    	    out     (IO_PSG1ADDR), a ; Set the PSG register
			
			    ; Expect comma
2269+11	2269  CF2C    	    SYNCHK  ','
			
			    ; Get value to write to PSG register
2280+17	226B  CD540B  	    call    GETBYT           ; Get/evaluate value
2297+11	226E  D3F6    	    out     (IO_PSG1DATA), a ; Send data to the selected PSG register
			
    -	2270          	.check_comma:
			    ; Check for a comma
2308+7	2270  7E      	    ld      a, (hl)          ; Get next character on command line
2315+7	2271  FE2C    	    cp      ','              ; Compare with ','
2322+5+6	2273  C0      	    ret     nz               ; No comma = no more parameters -> return
			
2327+6	2274  23      	    inc     hl               ; next character on command line
2333+12	2275  18E9    	    jr      .psgloop         ; parse next register & value
			
    -	2277          	.psg2:
2345+7	2277  D610    	    sub     16
2352+11	2279  D3F9    	    out     (IO_PSG2ADDR), a ; Set the PSG register
			
			    ; Expect comma
2363+11	227B  CF2C    	    SYNCHK  ','
			
			    ; Get value to write to PSG register
2374+17	227D  CD540B  	    call    GETBYT           ; Get/evaluate value
2391+11	2280  D3F8    	    out     (IO_PSG2DATA), a ; Send data to the selected PSG register
			
2402+12	2282  18EC    	    jr      .check_comma
			
			;-----------------------------------------------------------------------------
			; IN() function
			; syntax: var = IN(port)
			;-----------------------------------------------------------------------------
    -	2284          	FN_IN:
2414+10	2284  E1      	    pop     hl
2424+6	2285  23      	    inc     hl
			
2430+17	2286  CD370A  	    call    PARCHK           ; Read number from line - ending with a ')'
2447+19	2289  E3      	    ex      (sp), hl
2466+10	228A  11490A  	    ld      de, LABBCK       ; Return address
2476+11	228D  D5      	    push    de               ; On stack
2487+17	228E  CD8206  	    call    FRCINT           ; Evaluate formula pointed by HL, result in DE
2504+4	2291  42      	    ld      b, d
2508+4	2292  4B      	    ld      c, e             ; BC = port
			
			    ; Read from port
2512+12	2293  ED78    	    in      a, (c)           ; A = in(port)
2524+10	2295  C3360B  	    jp      SNGFLT           ; Return with 8 bit input value in variable var
			
			;-----------------------------------------------------------------------------
			; JOY() function
			; syntax: var = JOY(stick)
			;    stick - 0 will read left or right
			;          - 1 will read left joystick only
			;          - 2 will read right joystick only
			;-----------------------------------------------------------------------------
    -	2298          	FN_JOY:
2534+10	2298  E1      	    pop     hl             ; Return address
2544+6	2299  23      	    inc     hl             ; skip rst parameter
2550+17	229A  CD370A  	    call    PARCHK         ; Read number from line - ending with a ')'
2567+19	229D  E3      	    ex      (sp), hl
2586+10	229E  11490A  	    ld      de, LABBCK     ; set return address
2596+11	22A1  D5      	    push    de
2607+17	22A2  CD8206  	    call    FRCINT         ; FRCINT - evalute formula pointed by HL result in DE
			
2624+4	22A5  7B      	    ld      a, e
2628+4	22A6  B7      	    or      a
2632+7+5	22A7  2002    	    jr      nz, .joy01
2639+7	22A9  3E03    	    ld      a, $03
			
    -	22AB          	.joy01:
2646+4	22AB  5F      	    ld      e, a
2650+10	22AC  01F700  	    ld      bc, $00F7
2660+7	22AF  3EFF    	    ld      a, $FF
2667+8	22B1  CB43    	    bit     0, e
2675+7+5	22B3  280F    	    jr      z, .joy03
2682+7	22B5  3E0E    	    ld      a, $0e
2689+12	22B7  ED79    	    out     (c), a
2701+4	22B9  0D      	    dec     c
2705+7	22BA  06FF    	    ld      b, $FF
			
    -	22BC          	.joy02:
2712+12	22BC  ED78    	    in      a,(c)
2724+8+5	22BE  10FC    	    djnz    .joy02
2732+7	22C0  FEFF    	    cp      $FF
2739+7+5	22C2  2012    	    jr      nz, .joy05
			
    -	22C4          	.joy03:
2746+8	22C4  CB4B    	    bit     1,e
2754+7+5	22C6  280E    	    jr      z, .joy05
2761+10	22C8  01F700  	    ld      bc, $00F7
2771+7	22CB  3E0F    	    ld      a, $0F
2778+12	22CD  ED79    	    out     (c), a
2790+4	22CF  0D      	    dec     c
2794+7	22D0  06FF    	    ld      b, $FF
			
    -	22D2          	.joy04:
2801+12	22D2  ED78    	    in      a, (c)
2813+8+5	22D4  10FC    	    djnz    .joy04
			
    -	22D6          	.joy05:
2821+4	22D6  2F      	    cpl
2825+10	22D7  C3360B  	    jp      SNGFLT
			
			;-----------------------------------------------------------------------------
			; HEX$() function
			; eg. A$=HEX$(B)
			;-----------------------------------------------------------------------------
    -	22DA          	FN_HEX:
2835+10	22DA  E1      	    pop     hl
2845+6	22DB  23      	    inc     hl
2851+17	22DC  CD370A  	    call    PARCHK          ; Evaluate parameter in brackets
2868+19	22DF  E3      	    ex      (sp), hl
2887+10	22E0  11490A  	    ld      de, LABBCK      ; Return address
2897+11	22E3  D5      	    push    de              ; On stack
2908+17	22E4  CD8206  	    call    FRCINT          ; Evaluate formula @HL, result in DE
2925+10	22E7  21E938  	    ld      hl, FPSTR       ; HL = temp string
2935+4	22EA  7A      	    ld      a, d
2939+4	22EB  B7      	    or      a               ; > zero ?
2943+7+5	22EC  2804    	    jr      z, .lower_byte
2950+4	22EE  7A      	    ld      a, d
2954+17	22EF  CDFE22  	    call    .hexbyte        ; Yes, convert byte in D to hex string
    -	22F2          	.lower_byte:
2971+4	22F2  7B      	    ld      a, e
2975+17	22F3  CDFE22  	    call    .hexbyte        ; Convert byte in E to hex string
2992+10	22F6  3600    	    ld      (hl), 0         ; Null-terminate string
3002+10	22F8  21E938  	    ld      hl, FPSTR
    -	22FB          	.create_string:
3012+10	22FB  C32F0E  	    jp      $0E2F           ; Create BASIC string
			
    -	22FE          	.hexbyte:
3022+4	22FE  47      	    ld      b, a
3026+4	22FF  1F      	    rra
3030+4	2300  1F      	    rra
3034+4	2301  1F      	    rra
3038+4	2302  1F      	    rra
3042+17	2303  CD0723  	    call    .hex
3059+4	2306  78      	    ld      a, b
    -	2307          	.hex:
3063+7	2307  E60F    	    and     $0F
3070+7	2309  FE0A    	    cp      10
3077+7+5	230B  3802    	    jr      c, .chr
3084+7	230D  C607    	    add     7
    -	230F          	.chr:
3091+7	230F  C630    	    add     '0'
3098+7	2311  77      	    ld      (hl), a
3105+6	2312  23      	    inc     hl
3111+10	2313  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; ST_CALL
			;
			; syntax: CALL address
			; address is signed integer, 0 to 32767   = $0000-$7FFF
			;                            -32768 to -1 = $8000-$FFFF
			;
			; on entry to user code, HL = text after address
			; on exit from user code, HL should point to end of statement
			;-----------------------------------------------------------------------------
    -	2314          	ST_CALL:
3121+17	2314  CD7209  	    call    FRMNUM           ; Get number from BASIC text
3138+17	2317  CD8206  	    call    FRCINT           ; Convert to 16 bit integer
3155+11	231A  D5      	    push    de
3166+10	231B  C9      	    ret                      ; Jump to user code, HL = BASIC text pointer
			
			;-----------------------------------------------------------------------------
			; DOS commands
			;-----------------------------------------------------------------------------
			    include "espdos.asm"
**** espdos.asm ****
			;-----------------------------------------------------------------------------
			; espdos.asm
			;-----------------------------------------------------------------------------
			
			;-----------------------------------------------------------------------------
			; LOAD
			;
			; LOAD "filename"        Load BASIC program
			; LOAD "filename",12345  Load file as raw binary to address 12345
			; LOAD "filename",*a     Load data into numeric array a
			;-----------------------------------------------------------------------------
    -	231C          	ST_LOAD:
			    ; Close any open files
3176+17	231C  CD0027  	    call    esp_close_all
			
			    ; Get string parameter with path
3193+17	231F  CDCC26  	    call    get_string_parameter
			
			    ; Check for second parameter
3210+17	2322  CD9F27  	    call    get_arg
3227+7	2325  FE2C    	    cp      ','
3234+10	2327  C20B28  	    jp      nz, load_basic_program  ; No parameter -> load as basic program
3244+17	232A  CD9E27  	    call    get_next
3261+7	232D  FEAA    	    cp      $AA                     ; Token for '*'
3268+7+5	232F  280D    	    jr      z, .array               ; Array parameter -> load as array
			
			    ; Load as binary to address
3275+17	2331  CD7209  	    call    FRMNUM                  ; Get number
3292+17	2334  CD8206  	    call    FRCINT                  ; Convert to 16 bit integer
3309+20	2337  ED53FCBF	    ld      (BINSTART), de
3329+10	233B  C3CB27  	    jp      load_binary
			
			    ; Load into array
    -	233E          	.array:
3339+17	233E  CD4423  	    call    get_array_argument
3356+10	2341  C3DD27  	    jp      load_caq_array
			
			;-----------------------------------------------------------------------------
			; Get array argument
			;-----------------------------------------------------------------------------
    -	2344          	get_array_argument:
			    ; Skip '*' token
3366+6	2344  23      	    inc     hl
			
			    ; Get pointer to array variable
3372+7	2345  3E01    	    ld      a, 1
3379+13	2347  32CB38  	    ld      (SUBFLG), a         ; Set array flag
3392+17	234A  CDD110  	    call    PTRGET              ; Get array (out: BC = pointer to number of dimensions, DE = next array entry)
3409+13	234D  32CB38  	    ld      (SUBFLG), a         ; Clear array flag
3422+10	2350  C29706  	    jp      nz, FCERR           ; FC Error if array not found
3432+17	2353  CD7509  	    call    CHKNUM              ; TM error if not numeric
			
			    ; Get start address and length of array
3449+11	2356  E5      	    push    hl                  ; Push BASIC text pointer
3460+4	2357  60      	    ld      h, b
3464+4	2358  69      	    ld      l, c                ; HL = address
3468+7	2359  4E      	    ld      c, (hl)
3475+7	235A  0600    	    ld      b, 0                ; BC = index
3482+11	235C  09      	    add     hl, bc
3493+11	235D  09      	    add     hl, bc
3504+6	235E  23      	    inc     hl                  ; HL = array data
3510+16	235F  22FCBF  	    ld      (BINSTART), hl
3526+6	2362  1B      	    dec     de
3532+6	2363  1B      	    dec     de                  ; Subtract array header to get data length
3538+6	2364  1B      	    dec     de
3544+20	2365  ED53FEBF	    ld      (BINLEN), de
3564+10	2369  E1      	    pop     hl                  ; Pop text pointer
			
3574+10	236A  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; SAVE
			;
			; SAVE "filename"             Save BASIC program
			; SAVE "filename",addr,len    Save binary data
			; SAVE "filename",*a          Save numeric array a
			;-----------------------------------------------------------------------------
    -	236B          	ST_SAVE:
			    ; Close any open files
3584+17	236B  CD0027  	    call    esp_close_all
			
			    ; Get string parameter with path
3601+17	236E  CDCC26  	    call    get_string_parameter
			
			    ; Check for second parameter
3618+17	2371  CD9F27  	    call    get_arg
3635+7	2374  FE2C    	    cp      ','
3642+10	2376  C24828  	    jp      nz, save_basic_program
3652+17	2379  CD9E27  	    call    get_next
3669+7	237C  FEAA    	    cp      $AA                     ; Token for '*'
3676+7+5	237E  2820    	    jr      z, .array               ; Array parameter -> save array
			
			    ; Save binary data
			    
			    ; Get first parameter: address
3683+17	2380  CD7209  	    call    FRMNUM                  ; Get number
3700+17	2383  CD8206  	    call    FRCINT                  ; Convert to 16 bit integer
3717+20	2386  ED53FCBF	    ld      (BINSTART), de
			
			    ; Expect comma
3737+17	238A  CD9F27  	    call    get_arg
3754+7	238D  FE2C    	    cp      ','
3761+10	238F  C2D603  	    jp      nz, MOERR
3771+6	2392  23      	    inc     hl
			
			    ; Get second parameter: length
3777+17	2393  CD7209  	    call    FRMNUM                  ; Get number
3794+17	2396  CD8206  	    call    FRCINT                  ; Convert to 16 bit integer
3811+20	2399  ED53FEBF	    ld      (BINLEN), de
3831+10	239D  C3AA28  	    jp      save_binary
			
			    ; Save array
    -	23A0          	.array:
3841+17	23A0  CD4423  	    call    get_array_argument
3858+10	23A3  C37F28  	    jp      save_caq_array
			
			;-----------------------------------------------------------------------------
			; DEL - Delete file/directory
			;-----------------------------------------------------------------------------
    -	23A6          	ST_DEL:
			    ; Get string parameter
3868+17	23A6  CDCC26  	    call    get_string_parameter
			
			    ; Save BASIC text pointer
3885+11	23A9  E5      	    push    hl
			
			    ; Issue ESP command
3896+7	23AA  3E19    	    ld      a, ESPCMD_DELETE
3903+17	23AC  CD0726  	    call    esp_cmd
3920+17	23AF  CDEB26  	    call    esp_send_pathbuf
3937+17	23B2  CDF826  	    call    esp_get_result
			
			    ; Restore BASIC text pointer
3954+10	23B5  E1      	    pop     hl
3964+10	23B6  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; CD - Change directory
			;
			; No argument -> Show current directory
			; With argument -> Change current directory
			;-----------------------------------------------------------------------------
    -	23B7          	ST_CD:
			    ; Push BASIC text pointer
3974+11	23B7  E5      	    push    hl
			
			    ; Argument given?
3985+4	23B8  B7      	    or      a
3989+7+5	23B9  2018    	    jr      nz, .change_dir     ; Yes
			
			    ; -- No argument -> show current path ------------------------------------
    -	23BB          	.show_path:
3996+7	23BB  3E1E    	    ld      a, ESPCMD_GETCWD
4003+17	23BD  CD0726  	    call    esp_cmd
4020+17	23C0  CDF826  	    call    esp_get_result
			
			    ; Print current working directory
    -	23C3          	.print_cwd:
4037+17	23C3  CD1A26  	    call    esp_get_byte
4054+4	23C6  B7      	    or      a
4058+7+5	23C7  2805    	    jr      z, .print_done
4065+17	23C9  CD721D  	    call    TTYCHR
4082+12	23CC  18F5    	    jr      .print_cwd
    -	23CE          	.print_done:
4094+17	23CE  CDEA19  	    call    CRDO
			
    -	23D1          	.done:
			    ; Restore BASIC text pointer
4111+10	23D1  E1      	    pop     hl
4121+10	23D2  C9      	    ret
			
			    ; -- Argument given -> change directory ----------------------------------
    -	23D3          	.change_dir:
			    ; Restore BASIC text pointer
4131+10	23D3  E1      	    pop     hl
			
			    ; Get string parameter
4141+17	23D4  CDCC26  	    call    get_string_parameter
			
			    ; Save BASIC text pointer
4158+11	23D7  E5      	    push    hl
			
			    ; Issue ESP command
4169+7	23D8  3E1C    	    ld      a, ESPCMD_CHDIR
4176+17	23DA  CD0726  	    call    esp_cmd
4193+17	23DD  CDEB26  	    call    esp_send_pathbuf
4210+17	23E0  CDF826  	    call    esp_get_result
4227+12	23E3  18EC    	    jr      .done
			
			;-----------------------------------------------------------------------------
			; MKDIR - Create directory
			;-----------------------------------------------------------------------------
    -	23E5          	ST_MKDIR:
			    ; Get string parameter
4239+17	23E5  CDCC26  	    call    get_string_parameter
			
			    ; Save BASIC text pointer
4256+11	23E8  E5      	    push    hl
			
			    ; Issue ESP command
4267+7	23E9  3E1B    	    ld      a, ESPCMD_MKDIR
4274+17	23EB  CD0726  	    call    esp_cmd
4291+17	23EE  CDEB26  	    call    esp_send_pathbuf
4308+17	23F1  CDF826  	    call    esp_get_result
			
			    ; Restore BASIC text pointer
4325+10	23F4  E1      	    pop     hl
4335+10	23F5  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; DIR - Directory listing
			;
			; No argument -> List current directory
			; With argument -> List given path
			;-----------------------------------------------------------------------------
    -	23F6          	ST_DIR:
    -	3852          	    .tmp0: equ FILNAM+1
    -	3853          	    .tmp1: equ FILNAM+2
    -	3854          	    .tmp2: equ FILNAM+3
    -	3855          	    .tmp3: equ FILNAM+4
			
			    ; Preserve BASIC text pointer
4345+11	23F6  E5      	    push    hl
			
			    ; Argument given?
4356+4	23F7  B7      	    or      a
4360+7+5	23F8  2009    	    jr      nz, .witharg     ; Yes
			
4367+4	23FA  AF      	    xor     a
4371+13	23FB  3200BF  	    ld      (PATHLEN), a
4384+13	23FE  3201BF  	    ld      (PATHBUF), a
4397+12	2401  1805    	    jr      .esp_command
			
    -	2403          	.witharg:
4409+10	2403  E1      	    pop     hl                  ; Pop BASIC text pointer
4419+17	2404  CDCC26  	    call    get_string_parameter
4436+11	2407  E5      	    push    hl
			
    -	2408          	.esp_command:
4447+17	2408  CD0027  	    call    esp_close_all
			
			    ; Issue ESP command
4464+7	240B  3E16    	    ld      a, ESPCMD_OPENDIR
4471+17	240D  CD0726  	    call    esp_cmd
4488+17	2410  CDEB26  	    call    esp_send_pathbuf
4505+17	2413  CDF826  	    call    esp_get_result
			
			    ; Set initial number of lines per page
4522+7	2416  3E18    	    ld      a, 24
4529+13	2418  320838  	    ld      (CNTOFL), a
			
    -	241B          	.next_entry:
			    ; Read entry
4542+7	241B  3E18    	    ld      a, ESPCMD_READDIR
4549+17	241D  CD0726  	    call    esp_cmd
4566+4	2420  AF      	    xor     a
4570+17	2421  CD2326  	    call    esp_send_byte
4587+17	2424  CD1A26  	    call    esp_get_byte
			
4604+7	2427  FEFC    	    cp      ERR_EOF
4611+10	2429  CA5D25  	    jp      z, .done
4621+4	242C  B7      	    or      a
4625+10	242D  F23424  	    jp      p, .ok2
4635+10	2430  E1      	    pop     hl              ; Restore BASIC text pointer
4645+10	2431  C36F25  	    jp      esp_error
			
    -	2434          	.ok2:
			    ;-- Date -----------------------------------------------------------------
4655+17	2434  CD1A26  	    call    esp_get_byte
4672+13	2437  325238  	    ld      (.tmp0), a
4685+17	243A  CD1A26  	    call    esp_get_byte
4702+13	243D  325338  	    ld      (.tmp1), a
			
			    ; Extract year
4715+8	2440  CB3F    	    srl     a
4723+7	2442  C650    	    add     80
4730+17	2444  CD2E26  	    call    out_number_2digits
			
4747+7	2447  3E2D    	    ld      a, '-'
4754+17	2449  CD721D  	    call    TTYCHR
			
			    ; Extract month
4771+13	244C  3A5338  	    ld      a, (.tmp1)
4784+4	244F  1F      	    rra                     ; Lowest bit in carry
4788+13	2450  3A5238  	    ld      a, (.tmp0)
4801+4	2453  1F      	    rra
4805+8	2454  CB3F    	    srl     a
4813+8	2456  CB3F    	    srl     a
4821+8	2458  CB3F    	    srl     a
4829+8	245A  CB3F    	    srl     a
4837+17	245C  CD2E26  	    call    out_number_2digits
			
4854+7	245F  3E2D    	    ld      a, '-'
4861+17	2461  CD721D  	    call    TTYCHR
			
			    ; Extract day
4878+13	2464  3A5238  	    ld      a, (.tmp0)
4891+7	2467  E61F    	    and     $1F
4898+17	2469  CD2E26  	    call    out_number_2digits
			
4915+7	246C  3E20    	    ld      a, ' '
4922+17	246E  CD721D  	    call    TTYCHR
			
			    ;-- Time -----------------------------------------------------------------
			    ; Get time (hhhhhmmm mmmsssss)
4939+17	2471  CD1A26  	    call    esp_get_byte
4956+13	2474  325238  	    ld      (.tmp0), a
4969+17	2477  CD1A26  	    call    esp_get_byte
4986+13	247A  325338  	    ld      (.tmp1), a
			
			    ; Hours
4999+8	247D  CB3F    	    srl     a
5007+8	247F  CB3F    	    srl     a
5015+8	2481  CB3F    	    srl     a
5023+17	2483  CD2E26  	    call    out_number_2digits
			
5040+7	2486  3E3A    	    ld      a, ':'
5047+17	2488  CD721D  	    call    TTYCHR
			
			    ; Minutes
5064+13	248B  3A5338  	    ld      a, (.tmp1)
5077+7	248E  E607    	    and     $07
5084+4	2490  4F      	    ld      c, a
5088+13	2491  3A5238  	    ld      a, (.tmp0)
5101+8	2494  CB39    	    srl     c
5109+4	2496  1F      	    rra
5113+8	2497  CB39    	    srl     c
5121+4	2499  1F      	    rra
5125+8	249A  CB39    	    srl     c
5133+4	249C  1F      	    rra
5137+8	249D  CB39    	    srl     c
5145+4	249F  1F      	    rra
5149+8	24A0  CB39    	    srl     c
5157+4	24A2  1F      	    rra
5161+17	24A3  CD2E26  	    call    out_number_2digits
			
			    ;-- Attributes -----------------------------------------------------------
5178+17	24A6  CD1A26  	    call    esp_get_byte
5195+8	24A9  CB47    	    bit     0, a
5203+7+5	24AB  2814    	    jr      z, .no_dir
			
			    ;-- Directory ------------------------------------------------------------
5210+10	24AD  215625  	    ld      hl, .str_dir
5220+17	24B0  CD9D0E  	    call    STROUT
			
			    ; Skip length bytes
5237+17	24B3  CD1A26  	    call    esp_get_byte
5254+17	24B6  CD1A26  	    call    esp_get_byte
5271+17	24B9  CD1A26  	    call    esp_get_byte
5288+17	24BC  CD1A26  	    call    esp_get_byte
			
5305+12	24BF  187F    	    jr      .get_filename
			
			    ;-- Regular file: file size ----------------------------------------------
    -	24C1          	.no_dir:
			    ; aaaaaaaa bbbbbbbb cccccccc dddddddd
			
5317+17	24C1  CD1A26  	    call    esp_get_byte
5334+13	24C4  325238  	    ld      (.tmp0), a
5347+17	24C7  CD1A26  	    call    esp_get_byte
5364+13	24CA  325338  	    ld      (.tmp1), a
5377+17	24CD  CD1A26  	    call    esp_get_byte
5394+13	24D0  325438  	    ld      (.tmp2), a
5407+17	24D3  CD1A26  	    call    esp_get_byte
5424+13	24D6  325538  	    ld      (.tmp3), a
			
			    ; Megabytes range?
5437+4	24D9  B7      	    or      a
5441+7+5	24DA  2042    	    jr      nz, .mb
5448+13	24DC  3A5438  	    ld      a, (.tmp2)
5461+7	24DF  E6F0    	    and     $F0
5468+7+5	24E1  203B    	    jr      nz, .mb
			
			    ; Kilobytes range?
5475+13	24E3  3A5438  	    ld      a, (.tmp2)
5488+4	24E6  B7      	    or      a
5492+7+5	24E7  2019    	    jr      nz, .kb
5499+13	24E9  3A5338  	    ld      a, (.tmp1)
5512+7	24EC  E6FC    	    and     $FC
5519+7+5	24EE  2012    	    jr      nz, .kb
			
			    ; Bytes range (aaaaaaaa bbbbbbbb ccccccCC DDDDDDDD)
    -	24F0          	.bytes:
5526+13	24F0  3A5338  	    ld      a, (.tmp1)
5539+4	24F3  67      	    ld      h, a
5543+13	24F4  3A5238  	    ld      a, (.tmp0)
5556+4	24F7  6F      	    ld      l, a
5560+17	24F8  CD4D26  	    call    out_number_4digits
5577+7	24FB  3E42    	    ld      a, 'B'
5584+17	24FD  CD721D  	    call    TTYCHR
5601+12	2500  183E    	    jr      .get_filename
			
			    ; Kilobytes range: aaaaaaaa bbbbBBBB CCCCCCcc dddddddd
    -	2502          	.kb:
5613+13	2502  3A5438  	    ld      a, (.tmp2)
5626+7	2505  E60F    	    and     a, $0F
5633+4	2507  67      	    ld      h, a
5637+13	2508  3A5338  	    ld      a, (.tmp1)
5650+4	250B  6F      	    ld      l, a
5654+8	250C  CB3C    	    srl     h
5662+8	250E  CB1D    	    rr      l
5670+8	2510  CB3C    	    srl     h
5678+8	2512  CB1D    	    rr      l
5686+17	2514  CD4D26  	    call    out_number_4digits
5703+7	2517  3E4B    	    ld      a, 'K'
5710+17	2519  CD721D  	    call    TTYCHR
5727+12	251C  1822    	    jr      .get_filename
			
			    ; Megabytes range: AAAAAAAA BBBBbbbb cccccccc dddddddd
    -	251E          	.mb:
5739+13	251E  3A5538  	    ld      a, (.tmp3)
5752+4	2521  67      	    ld      h, a
5756+13	2522  3A5438  	    ld      a, (.tmp2)
5769+4	2525  6F      	    ld      l, a
5773+8	2526  CB3C    	    srl     h
5781+8	2528  CB1D    	    rr      l
5789+8	252A  CB3C    	    srl     h
5797+8	252C  CB1D    	    rr      l
5805+8	252E  CB3C    	    srl     h
5813+8	2530  CB1D    	    rr      l
5821+8	2532  CB3C    	    srl     h
5829+8	2534  CB1D    	    rr      l
5837+17	2536  CD4D26  	    call    out_number_4digits
5854+7	2539  3E4D    	    ld      a, 'M'
5861+17	253B  CD721D  	    call    TTYCHR
5878+12	253E  1800    	    jr      .get_filename
			
			    ;-- Filename -------------------------------------------------------------
    -	2540          	.get_filename:
5890+7	2540  3E20    	    ld      a, ' '
5897+17	2542  CD721D  	    call    TTYCHR
			
    -	2545          	.filename:
5914+17	2545  CD1A26  	    call    esp_get_byte
5931+4	2548  B7      	    or      a
5935+7+5	2549  2805    	    jr      z, .name_done
5942+17	254B  CD721D  	    call    TTYCHR
5959+12	254E  18F5    	    jr      .filename
			
    -	2550          	.name_done:
5971+17	2550  CDEA19  	    call    CRDO
5988+10	2553  C31B24  	    jp      .next_entry
			
    -	2556  203C4449	.str_dir: db " <DIR>",0
              523E00
			
    -	255D          	.done:
			    ; Close directory
5998+7	255D  3E17    	    ld      a, ESPCMD_CLOSEDIR
6005+17	255F  CD0726  	    call    esp_cmd
6022+4	2562  AF      	    xor     a
6026+17	2563  CD2326  	    call    esp_send_byte
6043+17	2566  CD1A26  	    call    esp_get_byte
6060+4	2569  B7      	    or      a
6064+10	256A  FA6F25  	    jp      m, esp_error
			
6074+10	256D  E1      	    pop     hl      ; Restore BASIC text pointer
6084+10	256E  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; esp_error
			;-----------------------------------------------------------------------------
    -	256F          	esp_error:
6094+8	256F  ED44    	    neg
6102+4	2571  3D      	    dec     a
6106+7	2572  FE08    	    cp      -ERR_NOT_EMPTY
6113+7+5	2574  3802    	    jr      c, .ok
6120+7	2576  3E05    	    ld      a, -ERR_OTHER - 1
			
    -	2578          	.ok:
6127+10	2578  218C25  	    ld      hl, .error_msgs
6137+4	257B  87      	    add     a,a
6141+4	257C  85      	    add     l
6145+4	257D  6F      	    ld      l, a
6149+4	257E  7C      	    ld      a, h
6153+7	257F  CE00    	    adc     a, 0
6160+4	2581  67      	    ld      h, a
6164+7	2582  7E      	    ld      a, (hl)
6171+6	2583  23      	    inc     hl
6177+7	2584  66      	    ld      h, (hl)
6184+4	2585  6F      	    ld      l, a
			
			    ; Print error message
6188+7	2586  3E3F    	    ld      a, '?'
6195+11	2588  DF      	    OUTCHR
6206+10	2589  C3F403  	    jp      ERRFN1
			
    -	258C          	.error_msgs:
    -	258C  9C25    	    dw .msg_err_not_found     ; -1: File / directory not found
    -	258E  A625    	    dw .msg_err_too_many_open ; -2: Too many open files / directories
    -	2590  B425    	    dw .msg_err_param         ; -3: Invalid parameter
    -	2592  C225    	    dw .msg_err_eof           ; -4: End of file / directory
    -	2594  C625    	    dw .msg_err_exists        ; -5: File already exists
    -	2596  D525    	    dw .msg_err_other         ; -6: Other error
    -	2598  E325    	    dw .msg_err_no_disk       ; -7: No disk
    -	259A  EB25    	    dw .msg_err_not_empty     ; -8: Not empty
			
    -	259C  4E6F7420	.msg_err_not_found:     db "Not found",0
              666F756E
              6400
    -	25A6  546F6F20	.msg_err_too_many_open: db "Too many open",0
              6D616E79
              206F7065
              6E00
    -	25B4  496E7661	.msg_err_param:         db "Invalid param",0
              6C696420
              70617261
              6D00
    -	25C2  454F4600	.msg_err_eof:           db "EOF",0
    -	25C6  416C7265	.msg_err_exists:        db "Already exists",0
              61647920
              65786973
              747300
    -	25D5  556E6B6E	.msg_err_other:         db "Unknown error",0
              6F776E20
              6572726F
              7200
    -	25E3  4E6F2064	.msg_err_no_disk:       db "No disk",0
              69736B00
    -	25EB  4E6F7420	.msg_err_not_empty:     db "Not empty",0
              656D7074
              7900
			
			;-----------------------------------------------------------------------------
			; Bad file error
			;-----------------------------------------------------------------------------
    -	25F5          	err_bad_file:
6216+10	25F5  21FE25  	    ld      hl, .msg_bad_file
			
			    ; Print error message
6226+7	25F8  3E3F    	    ld      a, '?'
6233+11	25FA  DF      	    OUTCHR
6244+10	25FB  C3F403  	    jp      ERRFN1
			
    -	25FE  42616420	.msg_bad_file:       db "Bad file",0
              66696C65
              00
			
			
			;-----------------------------------------------------------------------------
			; Issue command to ESP
			;-----------------------------------------------------------------------------
    -	2607          	esp_cmd:
6254+11	2607  F5      	    push    a
			
			    ; Drain RX FIFO
    -	2608          	.drain:
6265+11	2608  DBF4    	    in      a, (IO_ESPCTRL)
6276+7	260A  E601    	    and     a, 1
6283+7+5	260C  2804    	    jr      z, .done
6290+11	260E  DBF5    	    in      a, (IO_ESPDATA)
6301+12	2610  18F6    	    jr      .drain
    -	2612          	.done:
			
			    ; Issue start of command
6313+7	2612  3E80    	    ld      a, $80
6320+11	2614  D3F4    	    out     (IO_ESPCTRL), a
			
			    ; Issue command
6331+10	2616  F1      	    pop     a
6341+10	2617  C32326  	    jp      esp_send_byte
			
			;-----------------------------------------------------------------------------
			; Wait for data from ESP
			;-----------------------------------------------------------------------------
    -	261A          	esp_get_byte:
    -	261A          	.wait:
6351+11	261A  DBF4    	    in      a, (IO_ESPCTRL)
6362+7	261C  E601    	    and     a, 1
6369+7+5	261E  28FA    	    jr      z, .wait
6376+11	2620  DBF5    	    in      a, (IO_ESPDATA)
6387+10	2622  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Write data to ESP
			;-----------------------------------------------------------------------------
    -	2623          	esp_send_byte:
6397+11	2623  F5      	    push    a
			
    -	2624          	.wait:
6408+11	2624  DBF4    	    in      a, (IO_ESPCTRL)
6419+7	2626  E602    	    and     a, 2
6426+7+5	2628  20FA    	    jr      nz, .wait
			
6433+10	262A  F1      	    pop     a
6443+11	262B  D3F5    	    out     (IO_ESPDATA), a
6454+10	262D  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Output 2 number digit in A
			;-----------------------------------------------------------------------------
    -	262E          	out_number_2digits:
6464+7	262E  FE64    	    cp      100
6471+7+5	2630  3804    	    jr      c, .l0
6478+7	2632  D664    	    sub     a, 100
6485+12	2634  18F8    	    jr      out_number_2digits
    -	2636          	.l0:
6497+7	2636  0E00    	    ld      c, 0
    -	2638          	.l1:
6504+4	2638  0C      	    inc     c
6508+7	2639  D60A    	    sub     a, 10
6515+7+5	263B  30FB    	    jr      nc, .l1
6522+7	263D  C60A    	    add     a, 10
6529+11	263F  F5      	    push    a
			
6540+4	2640  79      	    ld      a, c
6544+7	2641  C62F    	    add     '0'-1
6551+17	2643  CD721D  	    call    TTYCHR
6568+10	2646  F1      	    pop     a
6578+7	2647  C630    	    add     '0'
6585+17	2649  CD721D  	    call    TTYCHR
6602+10	264C  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Output 4 number digit in HL
			;-----------------------------------------------------------------------------
    -	264D          	out_number_4digits:
6612+7	264D  1601    	    ld      d, 1
			
6619+10	264F  01F0D8  	    ld      bc, -10000
6629+17	2652  CD6A26  	    call    .num1
6646+10	2655  0118FC  	    ld      bc, -1000
6656+17	2658  CD6A26  	    call    .num1
6673+10	265B  019CFF  	    ld      bc, -100
6683+17	265E  CD6A26  	    call    .num1
6700+7	2661  0EF6    	    ld      c, -10
6707+17	2663  CD6A26  	    call    .num1
			
6724+7	2666  1600    	    ld      d, 0
6731+7	2668  0EFF    	    ld      c, -1
    -	266A          	.num1:
6738+7	266A  3EFF    	    ld      a, -1
    -	266C          	.num2:
6745+4	266C  3C      	    inc     a
6749+11	266D  09      	    add     hl, bc
6760+7+5	266E  38FC    	    jr      c, .num2
6767+15	2670  ED42    	    sbc     hl, bc
			
6782+4	2672  B7      	    or      a
6786+7+5	2673  2808    	    jr      z, .zero
			
6793+7	2675  1600    	    ld      d, 0
			
    -	2677          	.normal:
6800+7	2677  C630    	    add     '0'
6807+17	2679  CD721D  	    call    TTYCHR
6824+10	267C  C9      	    ret
			
    -	267D          	.zero:
6834+8	267D  CB42    	    bit     0, d
6842+7+5	267F  28F6    	    jr      z, .normal
6849+7	2681  3E20    	    ld      a, ' '
6856+17	2683  CD721D  	    call    TTYCHR
6873+10	2686  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Initialize BASIC Program
			;
			; Resets variables, arrays, string space etc.
			; Updates nextline pointers to match location of BASIC program in RAM
			;-----------------------------------------------------------------------------
    -	2687          	init_basic_program:
			    ; Set next statement to start of program
6883+16	2687  2A4F38  	    ld      hl, (TXTTAB)
6899+6	268A  2B      	    dec     hl
6905+16	268B  22CE38  	    ld      (SAVTXT), hl
			
			    ; Set DATPTR to start of program
6921+16	268E  22DC38  	    ld      (DATPTR), hl
			
			    ; Clear string space
6937+16	2691  2AAD38  	    ld      hl, (MEMSIZ)
6953+16	2694  22C138  	    ld      (FRETOP), hl
			
			    ; Clear simple variables
6969+16	2697  2AD638  	    ld      hl, (VARTAB)
6985+16	269A  22D838  	    ld      (ARYTAB), hl
			
			    ; Clear array table
7001+16	269D  22DA38  	    ld      (STREND), hl
			
			    ; Clear string buffer
7017+10	26A0  21B138  	    ld      hl, TEMPPT + 2
7027+16	26A3  22AF38  	    ld      (TEMPPT), hl
			
			    ; Set CONTinue position to 0
7043+4	26A6  AF      	    xor     a
7047+4	26A7  6F      	    ld      l, a
7051+4	26A8  67      	    ld      h, a
7055+16	26A9  22D438  	    ld      (OLDTXT), hl
			
			    ; Clear locator flag
7071+13	26AC  32CB38  	    ld      (SUBFLG), a
			
			    ; Clear array pointer???
7084+16	26AF  22DE38  	    ld      (VARNAM), hl
			
			    ; Fix up next line addresses in loaded BASIC program
    -	26B2          	.link_lines:
7100+20	26B2  ED5B4F38	    ld      de, (TXTTAB)        ; DE = start of BASIC program
    -	26B6          	.next_line:
7120+4	26B6  62      	    ld      h, d
7124+4	26B7  6B      	    ld      l, e                ; HL = DE
7128+7	26B8  7E      	    ld      a, (hl)
7135+6	26B9  23      	    inc     hl                  ; Test nextline address
7141+7	26BA  B6      	    or      (hl)
7148+7+5	26BB  280E    	    jr      z, .init_done       ; If $0000 then done
7155+6	26BD  23      	    inc     hl
7161+6	26BE  23      	    inc     hl                  ; Skip line number
7167+6	26BF  23      	    inc     hl
7173+4	26C0  AF      	    xor     a                   ; End of line = $00
    -	26C1          	.find_eol:
7177+7	26C1  BE      	    cp      (hl)                ; Search for end of line
7184+6	26C2  23      	    inc     hl
7190+7+5	26C3  20FC    	    jr      nz, .find_eol
7197+4	26C5  EB      	    ex      de, hl              ; HL = current line, DE = next line
7201+7	26C6  73      	    ld      (hl), e
7208+6	26C7  23      	    inc     hl                  ; Set address of next line
7214+7	26C8  72      	    ld      (hl), d
7221+12	26C9  18EB    	    jr      .next_line
    -	26CB          	.init_done:
7233+10	26CB  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Get string parameter and store it in PATHLEN/PATHBUF
			;-----------------------------------------------------------------------------
    -	26CC          	get_string_parameter:
			    ; Evaluate expression
7243+17	26CC  CD8509  	    call    FRMEVL
			
			    ; Save BASIC text pointer
7260+11	26CF  E5      	    push    hl
			
			    ; Get string length (this will check for string type)
7271+17	26D0  CDF70F  	    call    LEN1
			
			    ; Save length
7288+13	26D3  3200BF  	    ld      (PATHLEN), a
			
			    ; Get string pointer into HL
7301+6	26D6  23      	    inc     hl
7307+6	26D7  23      	    inc     hl
7313+7	26D8  46      	    ld      b, (hl)
7320+6	26D9  23      	    inc     hl
7326+7	26DA  66      	    ld      h, (hl)
7333+4	26DB  68      	    ld      l, b
			
			    ; Copy string to PATHBUF
7337+10	26DC  1101BF  	    ld      de, PATHBUF
7347+7	26DF  0600    	    ld      b, 0
7354+4	26E1  4F      	    ld      c, a
7358+4	26E2  B7      	    or      a
7362+7+5	26E3  2802    	    jr      z, .copy_done
7369+16+5	26E5  EDB0    	    ldir
    -	26E7          	.copy_done:
			
			    ; Zero-terminate string
7385+4	26E7  AF      	    xor     a
7389+7	26E8  12      	    ld      (de), a
			
			    ; Restore BASIC text pointer
7396+10	26E9  E1      	    pop     hl
7406+10	26EA  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Send PATHBUF including zero termination to ESPDATA
			;-----------------------------------------------------------------------------
    -	26EB          	esp_send_pathbuf:
7416+10	26EB  2101BF  	    ld      hl, PATHBUF
7426+7	26EE  1600    	    ld      d, 0
7433+13	26F0  3A00BF  	    ld      a, (PATHLEN)
7446+4	26F3  3C      	    inc     a               ; Include zero termination
7450+4	26F4  5F      	    ld      e, a
7454+10	26F5  C35327  	    jp      esp_send_bytes
			
			;-----------------------------------------------------------------------------
			; Get first result byte, and jump to error handler if it was an error
			;-----------------------------------------------------------------------------
    -	26F8          	esp_get_result:
7464+17	26F8  CD1A26  	    call    esp_get_byte
7481+4	26FB  B7      	    or      a
7485+10	26FC  FA6F25  	    jp      m, esp_error
7495+10	26FF  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Close any open file/directory descriptor
			;
			; Clobbered registers: A
			;-----------------------------------------------------------------------------
    -	2700          	esp_close_all:
7505+7	2700  3E1F    	    ld      a, ESPCMD_CLOSEALL
7512+17	2702  CD0726  	    call    esp_cmd
7529+10	2705  C3F826  	    jp      esp_get_result
			
			;-----------------------------------------------------------------------------
			; Open file in PATHBUF
			;
			; Clobbered registers: A, HL, DE
			;-----------------------------------------------------------------------------
    -	2708          	esp_open:
7539+7	2708  3E10    	    ld      a, ESPCMD_OPEN
7546+17	270A  CD0726  	    call    esp_cmd
7563+7	270D  3E00    	    ld      a, FO_RDONLY
7570+17	270F  CD2326  	    call    esp_send_byte
7587+17	2712  CDEB26  	    call    esp_send_pathbuf
7604+10	2715  C3F826  	    jp      esp_get_result
			
			;-----------------------------------------------------------------------------
			; Create file in PATHBUF
			;-----------------------------------------------------------------------------
    -	2718          	esp_create:
7614+7	2718  3E10    	    ld      a, ESPCMD_OPEN
7621+17	271A  CD0726  	    call    esp_cmd
7638+7	271D  3E19    	    ld      a, FO_WRONLY | FO_CREATE | FO_TRUNC
7645+17	271F  CD2326  	    call    esp_send_byte
7662+17	2722  CDEB26  	    call    esp_send_pathbuf
7679+10	2725  C3F826  	    jp      esp_get_result
			
			;-----------------------------------------------------------------------------
			; Read bytes
			; Input:  HL: destination address
			;         DE: number of bytes to read
			; Output: HL: next address (start address if no bytes read)
			;         DE: number of bytes actually read
			;
			; Clobbered registers: A, HL, DE
			;-----------------------------------------------------------------------------
    -	2728          	esp_read_bytes:
7689+7	2728  3E12    	    ld      a, ESPCMD_READ
7696+17	272A  CD0726  	    call    esp_cmd
			
			    ; Send file descriptor
7713+4	272D  AF      	    xor     a
7717+17	272E  CD2326  	    call    esp_send_byte
			
			    ; Send read size
7734+4	2731  7B      	    ld      a, e
7738+17	2732  CD2326  	    call    esp_send_byte
7755+4	2735  7A      	    ld      a, d
7759+17	2736  CD2326  	    call    esp_send_byte
			
			    ; Get result
7776+17	2739  CDF826  	    call    esp_get_result
			
			    ; Get number of bytes actual read
7793+17	273C  CD1A26  	    call    esp_get_byte
7810+4	273F  5F      	    ld      e, a
7814+17	2740  CD1A26  	    call    esp_get_byte
7831+4	2743  57      	    ld      d, a
			
7835+11	2744  D5      	    push    de
			
    -	2745          	.loop:
			    ; Done reading? (DE=0)
7846+4	2745  7A      	    ld      a, d
7850+4	2746  B3      	    or      a, e
7854+7+5	2747  2808    	    jr      z, .done
			
7861+17	2749  CD1A26  	    call    esp_get_byte
7878+7	274C  77      	    ld      (hl), a
7885+6	274D  23      	    inc     hl
7891+6	274E  1B      	    dec     de
7897+12	274F  18F4    	    jr      .loop
			
    -	2751          	.done:
7909+10	2751  D1      	    pop     de
7919+10	2752  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Send bytes
			; Input:  HL: source address
			;         DE: number of bytes to write
			; Output: HL: next address
			;         DE: number of bytes actually written
			;-----------------------------------------------------------------------------
    -	2753          	esp_send_bytes:
7929+11	2753  D5      	    push    de
			
    -	2754          	.loop:
			    ; Done sending? (DE=0)
7940+4	2754  7A      	    ld      a, d
7944+4	2755  B3      	    or      a, e
7948+7+5	2756  2808    	    jr      z, .done
			
7955+7	2758  7E      	    ld      a, (hl)
7962+17	2759  CD2326  	    call    esp_send_byte
7979+6	275C  23      	    inc     hl
7985+6	275D  1B      	    dec     de
7991+12	275E  18F4    	    jr      .loop
			
    -	2760          	.done:
8003+10	2760  D1      	    pop     de
8013+10	2761  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Write bytes
			; Input:  HL: source address
			;         DE: number of bytes to write
			; Output: HL: next address
			;         DE: number of bytes actually written
			;
			; Clobbered registers: A, HL, DE
			;-----------------------------------------------------------------------------
    -	2762          	esp_write_bytes:
8023+7	2762  3E13    	    ld      a, ESPCMD_WRITE
8030+17	2764  CD0726  	    call    esp_cmd
			
			    ; Send file descriptor
8047+4	2767  AF      	    xor     a
8051+17	2768  CD2326  	    call    esp_send_byte
			
			    ; Send write size
8068+4	276B  7B      	    ld      a, e
8072+17	276C  CD2326  	    call    esp_send_byte
8089+4	276F  7A      	    ld      a, d
8093+17	2770  CD2326  	    call    esp_send_byte
			
			    ; Send bytes
8110+17	2773  CD5327  	    call    esp_send_bytes
			
			    ; Get result
8127+17	2776  CDF826  	    call    esp_get_result
			
			    ; Get number of bytes actual written
8144+17	2779  CD1A26  	    call    esp_get_byte
8161+4	277C  5F      	    ld      e, a
8165+17	277D  CD1A26  	    call    esp_get_byte
8182+4	2780  57      	    ld      d, a
			
8186+10	2781  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Seek
			; Input:  DE: offset
			;
			; Clobbered registers: A, DE
			;-----------------------------------------------------------------------------
    -	2782          	esp_seek:
8196+7	2782  3E14    	    ld      a, ESPCMD_SEEK
8203+17	2784  CD0726  	    call    esp_cmd
			
			    ; Send file descriptor
8220+4	2787  AF      	    xor     a
8224+17	2788  CD2326  	    call    esp_send_byte
			
			    ; Send offset
8241+4	278B  7B      	    ld      a, e
8245+17	278C  CD2326  	    call    esp_send_byte
8262+4	278F  7A      	    ld      a, d
8266+17	2790  CD2326  	    call    esp_send_byte
8283+4	2793  AF      	    xor     a
8287+17	2794  CD2326  	    call    esp_send_byte
8304+17	2797  CD2326  	    call    esp_send_byte
			
			    ; Get result
8321+17	279A  CDF826  	    call    esp_get_result
8338+10	279D  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Get next character, skipping spaces
			;  in: HL = text pointer
			; out: NZ, A = next non-space char, HL = address of char in text
			;      Z,  A = 0, HL = end of text
			;-----------------------------------------------------------------------------
    -	279E          	get_next:                   ; Starting at next location
8348+6	279E  23      	    inc     hl
    -	279F          	get_arg:                    ; Starting at current location
8354+7	279F  7E      	    ld      a, (hl)
8361+4	27A0  B7      	    or      a
8365+5+6	27A1  C8      	    ret     z               ; Return Z if NULL
8370+7	27A2  FE20    	    cp      ' '
8377+5+6	27A4  C0      	    ret     nz              ; Return NZ if not SPACE
8382+12	27A5  18F7    	    jr      get_next
			
			;-----------------------------------------------------------------------------
			; Check for sync sequence (12x$FF, 1x$00)
			;-----------------------------------------------------------------------------
    -	27A7          	check_sync_bytes:
			    ; Read 13 bytes into TMPBUF
8394+10	27A7  110D00  	    ld      de, 13
8404+10	27AA  21ECBF  	    ld      hl, TMPBUF
8414+17	27AD  CD2827  	    call    esp_read_bytes
8431+4	27B0  7B      	    ld      a, e
8435+7	27B1  FE0D    	    cp      13
8442+10	27B3  C2F525  	    jp      nz, err_bad_file
			
			    ; Check for 12x$FF
8452+7	27B6  0E0C    	    ld      c, 12
8459+10	27B8  21ECBF  	    ld      hl, TMPBUF
    -	27BB          	.loop:
8469+7	27BB  7E      	    ld      a, (hl)
8476+7	27BC  FEFF    	    cp      $FF
8483+10	27BE  C2F525  	    jp      nz, err_bad_file
8493+6	27C1  23      	    inc     hl
8499+4	27C2  0D      	    dec     c
8503+7+5	27C3  20F6    	    jr      nz, .loop
			
			    ; Check for $00
8510+7	27C5  7E      	    ld      a, (hl)
8517+4	27C6  B7      	    or      a
8521+10	27C7  C2F525  	    jp      nz, err_bad_file
8531+10	27CA  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Load binary data in PATHBUF into BINSTART;
			;
			; Clobbered registers: A, DE
			;-----------------------------------------------------------------------------
    -	27CB          	load_binary:
8541+11	27CB  E5      	    push    hl
			
			    ; Load file into memory
8552+17	27CC  CD0827  	    call    esp_open
8569+16	27CF  2AFCBF  	    ld      hl, (BINSTART)
8585+10	27D2  11FFFF  	    ld      de, $FFFF
8595+17	27D5  CD2827  	    call    esp_read_bytes
8612+17	27D8  CD0027  	    call    esp_close_all
			
8629+10	27DB  E1      	    pop     hl
8639+10	27DC  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Load CAQ array file in PATHBUF into BINSTART (BINLEN length)
			;-----------------------------------------------------------------------------
    -	27DD          	load_caq_array:
8649+11	27DD  E5      	    push    hl
			
			    ; Open file
8660+17	27DE  CD0827  	    call    esp_open
			
			    ; Check CAQ header
8677+17	27E1  CDA727  	    call    check_sync_bytes    ; Sync bytes
8694+10	27E4  110600  	    ld      de, 6               ; Check that filename is '######'
8704+10	27E7  21ECBF  	    ld      hl, TMPBUF
8714+17	27EA  CD2827  	    call    esp_read_bytes
8731+7	27ED  0E06    	    ld      c, 6
8738+10	27EF  21ECBF  	    ld      hl, TMPBUF
    -	27F2          	.loop:
8748+7	27F2  7E      	    ld      a, (hl)
8755+7	27F3  FE23    	    cp      '#'
8762+10	27F5  C2F525  	    jp      nz, err_bad_file
8772+6	27F8  23      	    inc     hl
8778+4	27F9  0D      	    dec     c
8782+7+5	27FA  20F6    	    jr      nz, .loop
			
			    ; Load data into array
8789+16	27FC  2AFCBF  	    ld      hl, (BINSTART)
8805+20	27FF  ED5BFEBF	    ld      de, (BINLEN)
8825+17	2803  CD2827  	    call    esp_read_bytes
			
			    ; Close file
8842+17	2806  CD0027  	    call    esp_close_all
			
8859+10	2809  E1      	    pop     hl
8869+10	280A  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Load CAQ/BAS file in PATHBUF
			;-----------------------------------------------------------------------------
    -	280B          	load_basic_program:
8879+11	280B  E5      	    push    hl
			
			    ; Open file
8890+17	280C  CD0827  	    call    esp_open            
			
			    ; Check CAQ header
8907+17	280F  CDA727  	    call    check_sync_bytes    ; Sync bytes
8924+10	2812  110600  	    ld      de, 6               ; Skip filename
8934+10	2815  21ECBF  	    ld      hl, TMPBUF
8944+17	2818  CD2827  	    call    esp_read_bytes
8961+17	281B  CDA727  	    call    check_sync_bytes    ; Sync bytes
			    
			    ; Load actual program
8978+16	281E  2A4F38  	    ld      hl, (TXTTAB)
8994+10	2821  11FFFF  	    ld      de, $FFFF
9004+17	2824  CD2827  	    call    esp_read_bytes
			
			    ; Close file
9021+17	2827  CD0027  	    call    esp_close_all
			
			    ; Back up to last line of BASIC program
    -	282A          	.loop:
9038+6	282A  2B      	    dec     hl
9044+4	282B  AF      	    xor     a
9048+7	282C  BE      	    cp      (hl)
9055+7+5	282D  28FB    	    jr      z, .loop
9062+6	282F  23      	    inc     hl
			
			    ; Skip past 3 zeros at end of BASIC program
9068+6	2830  23      	    inc     hl
9074+6	2831  23      	    inc     hl
9080+6	2832  23      	    inc     hl
			
			    ; Set end of BASIC program
9086+16	2833  22D638  	    ld      (VARTAB), hl
			
			    ; Initialize BASIC program
9102+17	2836  CD8726  	    call    init_basic_program
			
9119+10	2839  E1      	    pop     hl
9129+10	283A  C9      	    ret
			
    -	283B          	sync_bytes:
    -	283B  FFFFFFFF	    db $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$00
              FFFFFFFF
              FFFFFFFF
              00
			
			;-----------------------------------------------------------------------------
			; Save basic program
			;-----------------------------------------------------------------------------
    -	2848          	save_basic_program:
9139+11	2848  E5      	    push    hl
			
			    ; Create file
9150+17	2849  CD1827  	    call    esp_create
			
			    ; Write CAQ header
9167+10	284C  213B28  	    ld      hl, sync_bytes      ; Sync bytes
9177+10	284F  110D00  	    ld      de, 13
9187+17	2852  CD6227  	    call    esp_write_bytes
9204+10	2855  217928  	    ld      hl, .caq_filename   ; Filename
9214+10	2858  110600  	    ld      de, 6
9224+17	285B  CD6227  	    call    esp_write_bytes
9241+10	285E  213B28  	    ld      hl, sync_bytes      ; Sync bytes
9251+10	2861  110D00  	    ld      de, 13
9261+17	2864  CD6227  	    call    esp_write_bytes
			
			    ; Write BASIC data
9278+20	2867  ED5B4F38	    ld      de, (TXTTAB)            ; DE = start of BASIC program
9298+16	286B  2AD638  	    ld      hl, (VARTAB)            ; HL = end of BASIC program
9314+15	286E  ED52    	    sbc     hl, de
9329+4	2870  EB      	    ex      de, hl                  ; HL = start, DE = length of BASIC program
9333+17	2871  CD6227  	    call    esp_write_bytes
			
			    ; Close file
9350+17	2874  CD0027  	    call    esp_close_all
			
9367+10	2877  E1      	    pop     hl
9377+10	2878  C9      	    ret
			
    -	2879  42415350	.caq_filename: db "BASPRG"
              5247
			
			;-----------------------------------------------------------------------------
			; Save array
			;-----------------------------------------------------------------------------
    -	287F          	save_caq_array:
9387+11	287F  E5      	    push    hl
			
			    ; Create file
9398+17	2880  CD1827  	    call    esp_create
			
			    ; Write CAQ header
9415+10	2883  213B28  	    ld      hl, sync_bytes      ; Sync bytes
9425+10	2886  110D00  	    ld      de, 13
9435+17	2889  CD6227  	    call    esp_write_bytes
9452+10	288C  21A428  	    ld      hl, .array_filename ; Filename
9462+10	288F  110600  	    ld      de, 6
9472+17	2892  CD6227  	    call    esp_write_bytes
			
			    ; Write array data
9489+16	2895  2AFCBF  	    ld      hl, (BINSTART)
9505+20	2898  ED5BFEBF	    ld      de, (BINLEN)
9525+17	289C  CD6227  	    call    esp_write_bytes
			
			    ; Close file
9542+17	289F  CD0027  	    call    esp_close_all
			
9559+10	28A2  E1      	    pop     hl
9569+10	28A3  C9      	    ret
			
    -	28A4  23232323	.array_filename: db "######"
              2323
			
			;-----------------------------------------------------------------------------
			; Save binary
			;-----------------------------------------------------------------------------
    -	28AA          	save_binary:
9579+11	28AA  E5      	    push    hl
			
			    ; Create file
9590+17	28AB  CD1827  	    call    esp_create
			
			    ; Write binary data
9607+16	28AE  2AFCBF  	    ld      hl, (BINSTART)
9623+20	28B1  ED5BFEBF	    ld      de, (BINLEN)
9643+17	28B5  CD6227  	    call    esp_write_bytes
			
			    ; Close file
9660+17	28B8  CD0027  	    call    esp_close_all
			
9677+10	28BB  E1      	    pop     hl
9687+10	28BC  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Run file
			;-----------------------------------------------------------------------------
    -	28BD          	run_file:
			    ; Close any open files
9697+17	28BD  CD0027  	    call    esp_close_all
			
			    ; Get string parameter with path
9714+17	28C0  CDCC26  	    call    get_string_parameter
			
			    ; Check for .ROM extension
9731+13	28C3  3A00BF  	    ld      a, (PATHLEN)
9744+7	28C6  FE05    	    cp      a, 5
9751+7+5	28C8  380D    	    jr      c, .load_basic      ; Too short to have ROM extension
9758+7	28CA  D603    	    sub     a, 3
9765+7	28CC  16BF    	    ld      d, PATHBUF >> 8
9772+4	28CE  5F      	    ld      e, a
9776+10	28CF  21E928  	    ld      hl, .romext
9786+17	28D2  CDDD28  	    call    .cmp
9803+7+5	28D5  2817    	    jr      z, load_rom
			
    -	28D7          	.load_basic:
9810+17	28D7  CD0B28  	    call    load_basic_program
9827+10	28DA  C3CB0B  	    jp      RUNC
			
    -	28DD          	.cmp:
9837+7	28DD  1A      	    ld      a, (de)         ; Get char from string 2
9844+17	28DE  CD4029  	    call    to_upper
9861+6	28E1  13      	    inc     de
9867+7	28E2  BE      	    cp      (hl)            ; Compare to char in string 1
9874+6	28E3  23      	    inc     hl
9880+5+6	28E4  C0      	    ret     nz              ; Return NZ if not equal
9885+4	28E5  B7      	    or      a
9889+7+5	28E6  20F5    	    jr      nz, .cmp        ; Loop until end of strings
9896+10	28E8  C9      	    ret                     ; Return Z
			
    -	28E9  2E524F4D	.romext: db ".ROM",0
              00
			
			;-----------------------------------------------------------------------------
			; Load ROM file
			;-----------------------------------------------------------------------------
    -	28EE          	load_rom:
			    ; Open file
9906+17	28EE  CD0827  	    call    esp_open
			
			    ; Map RAM in bank3
9923+7	28F1  3E23    	    ld      a, 35
9930+11	28F3  D3F3    	    out     (IO_BANK3), a
			
			    ; Load file
9941+10	28F5  2100C0  	    ld      hl, $C000
9951+10	28F8  110040  	    ld      de, $4000
9961+17	28FB  CD2827  	    call    esp_read_bytes
			
			    ; Check length
9978+4	28FE  7A      	    ld      a, d
9982+7	28FF  FE20    	    cp      $20         ; 8KB ROM?
9989+7+5	2901  200B    	    jr      nz, .ok
			
			    ; 8KB ROM, duplicate data to second 8KB area
9996+10	2903  2100C0  	    ld      hl, $C000
10006+10	2906  1100E0  	    ld      de, $E000
10016+10	2909  010020  	    ld      bc, $2000
10026+16+5	290C  EDB0    	    ldir
    -	290E          	.ok:
10042+17	290E  CD0027  	    call    esp_close_all
			
    -	2911          	descramble_rom:
			    ; Determine scramble value
10059+4	2911  AF      	    xor     a
10063+10	2912  2103E0  	    ld      hl, $E003
10073+7	2915  060C    	    ld      b, 12
    -	2917          	.loop:
10080+7	2917  86      	    add     a, (hl)
10087+6	2918  23      	    inc     hl
10093+4	2919  80      	    add     a, b
10097+4	291A  05      	    dec     b
10101+7+5	291B  20FA    	    jr      nz, .loop
10108+7	291D  AE      	    xor     (hl)
10115+4	291E  47      	    ld      b, a
			
			    ; Descramble ROM
10119+10	291F  2100C0  	    ld      hl, $C000
10129+10	2922  110040  	    ld      de, $4000
    -	2925          	.loop2:
10139+4	2925  78      	    ld      a, b
10143+7	2926  AE      	    xor     (hl)
10150+7	2927  77      	    ld      (hl), a
			
10157+6	2928  23      	    inc     hl
10163+6	2929  1B      	    dec     de
10169+4	292A  7A      	    ld      a, d
10173+4	292B  B3      	    or      e
10177+7+5	292C  20F7    	    jr      nz, .loop2
			
			    ; Reinit banks
10184+7	292E  3E21    	    ld      a, 33
10191+11	2930  D3F1    	    out     (IO_BANK1), a
10202+7	2932  3E22    	    ld      a, 34
10209+11	2934  D3F2    	    out     (IO_BANK2), a
			
			    ; Bank3 -> readonly
10220+7	2936  3EA3    	    ld      a, 35 | BANK_READONLY
10227+11	2938  D3F3    	    out     (IO_BANK3), a
			
			    ; Reinit stack pointer
10238+10	293A  31A038  	    ld      sp, $38A0
			
			    ; Start ROM
10248+10	293D  C310E0  	    jp      $E010
**** sdbasic.asm ****
			
			;-----------------------------------------------------------------------------
			; Convert lower-case to upper-case
			; in-out; A = char
			;-----------------------------------------------------------------------------
    -	2940          	to_upper:
10258+7	2940  FE61    	    cp      'a'             ; >='a'?
10265+5+6	2942  D8      	    ret     c
10270+7	2943  FE7B    	    cp      'z'+1           ; <='z'?
10277+5+6	2945  D0      	    ret     nc
10282+7	2946  D620    	    sub     $20             ; a-z -> A-Z
10289+10	2948  C9      	    ret
			
			;-----------------------------------------------------------------------------
			; Print value in A as hex value
			;-----------------------------------------------------------------------------
			; printhex:
			;     push    a
			
			;     ; Print upper-nibble
			;     srl     a
			;     srl     a
			;     srl     a
			;     srl     a
			;     call    .print
			
			;     pop     a
			;     push    a
			
			;     ; Print lower-nibble
			;     and     $0F
			;     call    .print
			
			;     pop     a
			;     ret
			
			; .print:
			;     add     '0'
			;     cp      ':'
			;     jr      c, .print2
			;     add     7
			; .print2:
			;     jp      TTYCHR
			
			;-----------------------------------------------------------------------------
			; Fill with $FF to start of Key Decode Tables
			;-----------------------------------------------------------------------------
    -	0001          	    assert !($2EFF<$)   ; ROM full!
    -	2949 ..2EFF FF	    dc $2EFF-$+1,$FF
			
			;-----------------------------------------------------------------------------
			; Keyboard Decode Tables for S3 BASIC with Extended Keyboard Support
			; Must be located at $2F00
			;
			; Non-printable keys generate High ASCII characters
			;
			; Key: PrtSc Pause PgUp PgDn Tab Right Up  SysRq Break End Home Menu Ins Left Down
			; Hex:  $88   $89  $8A  $8B  $8C $8E   $8F  $98   $99  $9A $9B  $9C  $9D $9E  $9F
			; Dec:  136   137  138  139  140 142   143  152   153  154 155  156  157 158  159
			;
			; Key: F1  F2  F3  F4  F5  F6  F7  F8  F9  F10 F11 F12    Function Keys are
			; Hex: $80 $81 $82 $83 $84 $85 $86 $87 $90 $91 $92 $93    not implented yet
			; Dec: 128 129 130 131 132 133 134 135 144 145 146 147
			;
			;-----------------------------------------------------------------------------
			
    -	2F00          	key_tables:
			; Unshifted Keys
    -	2F00  3D083A0D	    byte    '=',$08,':',$0D,';','.',$9D,$7F ; Backspace, Return, INS DEL
              3B2E9D7F
    -	2F08  2D2F3070	    byte    '-','/','0','p','l',',',$8F,$8E ; CsrUp, CsrRt
              6C2C8F8E
    -	2F10  396F6B6D	    byte    '9','o','k','m','n','j',$9E,$9F ; CsrLf, CsrDn
              6E6A9E9F
    -	2F18  38693775	    byte    '8','i','7','u','h','b',$9B,$9A ; Home, End
              68629B9A
    -	2F20  36796776	    byte    '6','y','g','v','c','f',$8A,$8B ; PgUp, PgDn
              63668A8B
    -	2F28  35743472	    byte    '5','t','4','r','d','x',$89,$88 ; Pause, PrtScr
              64788988
    -	2F30  3365737A	    byte    '3','e','s','z',' ','a',$9C,$8C ; Menu, Tab
              20619C8C
    -	2F38  32773171	    byte    '2','w','1','q', 0 , 0 , 0 ,$8D ; GUI
              0000008D
			; Shifted Keys
    -	2F40  2B5C2A0D	    byte    '+',$5C,'*',$0D,'@','>',$00,$00 ; Backslash, Return
              403E0000
    -	2F48  5F5E3F50	    byte    '_','^','?','P','L','<',$00,$00
              4C3C0000
    -	2F50  294F4B4D	    byte    ')','O','K','M','N','J',$00,$00
              4E4A0000
    -	2F58  28492755	    byte    '(','I',$27,'U','H','B',$00,$00 ; Apostrophe
              48420000
    -	2F60  26594756	    byte    '&','Y','G','V','C','F',$00,$00
              43460000
    -	2F68  25542452	    byte    '%','T','$','R','D','X',$00,$00
              44580000
    -	2F70  2345535A	    byte    '#','E','S','Z',' ','A',$00,$00
              20410000
    -	2F78  22572151	    byte    $22,'W','!','Q', 0 , 0 , 0 , 0  ; Quotation Mark
              00000000
			; Control Keys
    -	2F80  1B7F1D0D	    byte    $1B,$7F,$1D,$0D,$A0,$7D,$00,$00 ; ESC DEL GS  CR  NUL  }
              A07D0000
    -	2F88  1F1E1C10	    byte    $1F,$1E,$1C,$10,$0C,$7B,$00,$00 ; GS  RS  FS  DLE FF   {
              0C7B0000
    -	2F90  5D0F0B0D	    byte    $5D,$0F,$0B,$0D,$0E,$0A,$00,$00 ;  ]  SI  VT  CR  SO  LF
              0E0A0000
    -	2F98  5B096015	    byte    $5B,$09,$60,$15,$08,$02,$00,$00 ;  [  Tab  `  NAK BS  SOH
              08020000
    -	2FA0  8E190716	    byte    $8E,$19,$07,$16,$03,$06,$99,$00 ; rt  EM  BEL SYN ETX ACK Break
              03069900
    -	2FA8  9F148F12	    byte    $9F,$14,$8F,$12,$04,$18,$00,$00 ; dn  DC4 up  DC2 EOT CAN
              04180000
    -	2FB0  9E05131A	    byte    $9E,$05,$13,$1A,' ',$01,$00,$00 ; lft ENC DC3 SUB     SOH
              20010000
    -	2FB8  7E177C11	    byte    $7E,$17,$7C,$11, 0 , 0 , 0 , 0  ;  ~  ETB  |  DC1
              00000000
			
			;-----------------------------------------------------------------------------
			; SysROM File Name
			;-----------------------------------------------------------------------------
			
    -	2FC0 ..2FEF FF	    dc $2FEF-$+1,$FF
    -	2FF0  73646261	    byte    "sdbasic.bin"
              7369632E
              62696E
    -	2FFB ..2FFF 00	    dc $2FFF-$+1,$00
			    
			
			;-----------------------------------------------------------------------------
			; Verify ROM is correct length
			;-----------------------------------------------------------------------------
			
    -	0001          	    assert !($3000<>$)   ; Incorrect ROM! length
			
			;-----------------------------------------------------------------------------
			; Append Character Sets
			;-----------------------------------------------------------------------------
			    
    -	3000 ..3FFF 	    incbin  "aqpluschar.rom"
			
    -	4000          	    end



Statistics:

     4	passes
     0	jr promotions
   356	symbols
  8192	bytes

     7	macro calls
    61	macro bytes
     0	invented symbols



Symbol Table:

.array$29       233E      9022
.array$31       23A0      9120
.array_filename$62 28A4      10404
.bytes$35       24F0      9456
.caq_filename$61 2879      10361
.change_dir$33  23D3      9171
.check_comma$24 2270      8816
.chr$27         230F      8975
.cmp$64         28DD      10461
.copy_done$44   26E7      9959
.create_string$27 22FB      8955
.default_palette$1 203E      8254
.descramble$4   20F3      8435
.done$33        23D1      9169
.done$35        255D      9565
.done$38        2612      9746
.done$50        2751      10065
.done$51        2760      10080
.drain$38       2608      9736
.error_msgs$36  258C      9612
.esp_command$35 2408      9224
.expand_token$17 21C7      8647
.filename$35    2545      9541
.find_eol$43    26C1      9921
.get_filename$35 2540      9536
.goto_hl$23     2239      8761
.hex$27         2307      8967
.hexbyte$27     22FE      8958
.init_done$43   26CB      9931
.joy01$26       22AB      8875
.joy02$26       22BC      8892
.joy03$26       22C4      8900
.joy04$26       22D2      8914
.joy05$26       22D6      8918
.kb$35          2502      9474
.l0$41          2636      9782
.l1$41          2638      9784
.link_lines$43  26B2      9906
.load_basic$64  28D7      10455
.loop$50        2745      10053
.loop$51        2754      10068
.loop$56        27BB      10171
.loop$58        27F2      10226
.loop$59        282A      10282
.loop$66        2917      10519
.loop2$66       2925      10533
.lower_byte$27  22F2      8946
.mb$35          251E      9502
.msg_bad_file$37 25FE      9726
.msg_err_eof$36 25C2      9666
.msg_err_exists$36 25C6      9670
.msg_err_no_disk$36 25E3      9699
.msg_err_not_empty$36 25EB      9707
.msg_err_not_found$36 259C      9628
.msg_err_other$36 25D5      9685
.msg_err_param$36 25B4      9652
.msg_err_too_many_open$36 25A6      9638
.name_done$35   2550      9552
.next_entry$35  241B      9243
.next_line$43   26B6      9910
.no_dir$35      24C1      9409
.normal$42      2677      9847
.num1$42        266A      9834
.num2$42        266C      9836
.ok$36          2578      9592
.ok$65          290E      10510
.ok2$35         2434      9268
.palloop$1      2029      8233
.print_cwd$33   23C3      9155
.print_done$3   20B7      8375
.print_done$33  23CE      9166
.print_version$3 20AC      8364
.process$18     21D7      8663
.psg2$24        2277      8823
.psgloop$24     2260      8800
.romext$64      28E9      10473
.show_path$33   23BB      9147
.str_basic$3    20DD      8413
.str_dir$35     2556      9558
.str_system$3   20C9      8393
.tmp0$35       =3852      14418
.tmp1$35       =3853      14419
.tmp2$35       =3854      14420
.tmp3$35       =3855      14421
.ver_basic$3    20E6      8422
.wait$39        261A      9754
.wait$40        2624      9764
.witharg$35     2403      9219
.zero$42        267D      9853
ARYTAB         =38D8      14552
BANK0_BASE     =00        0
BANK1_BASE     =4000      16384
BANK2_BASE     =8000      32768
BANK3_BASE     =C000      49152
BANK_OVERLAY   =40        64
BANK_READONLY  =80        128
BASIC_RAM_END  =BEFF      48895
BASTXT         =3901      14593
BCOUNT         =0D        13
BINLEN         =BFFE      49150
BINSTART       =BFFC      49148
BTOKEN         =D4        212
BUF            =3860      14432
BUFMIN         =385F      14431
CHARC          =380A      14346
CHKNUM         = 975      2421
CHKSTR         = 976      2422
CLEARC         = BCF      3023
CLFLAG         =385E      14430
CLMLST         =3849      14409
CNTOFL         =3808      14344
COLOR          =3400      13312
CRDO           =19EA      6634
CURCHR         =380D      14349
CURLIN         =384D      14413
CURRAM         =3801      14337
DATLIN         =38C9      14537
DATPTR         =38DC      14556
DIMFLG         =38AA      14506
DORES          =38AC      14508
DSCTMP         =38BD      14525
ENDBUF         =38A9      14505
ENDFOR         =38C7      14535
ERRFN1         = 3F4      1012
ERROR          = 3DB      987
ERR_EOF        =FFFFFFFC  -4
ERR_EXISTS     =FFFFFFFB  -5
ERR_NOT_EMPTY  =FFFFFFF8  -8
ERR_NOT_FOUND  =FFFFFFFF  -1
ERR_NO_DISK    =FFFFFFF9  -7
ERR_OTHER      =FFFFFFFA  -6
ERR_PARAM      =FFFFFFFD  -3
ERR_TOO_MANY_OPEN=FFFFFFFE  -2
ESPCMD_CHDIR   =1C        28
ESPCMD_CLOSE   =11        17
ESPCMD_CLOSEALL=1F        31
ESPCMD_CLOSEDIR=17        23
ESPCMD_DELETE  =19        25
ESPCMD_GETCWD  =1E        30
ESPCMD_MKDIR   =1B        27
ESPCMD_OPEN    =10        16
ESPCMD_OPENDIR =16        22
ESPCMD_READ    =12        18
ESPCMD_READDIR =18        24
ESPCMD_RENAME  =1A        26
ESPCMD_RESET   =01        1
ESPCMD_SEEK    =14        20
ESPCMD_STAT    =1D        29
ESPCMD_TELL    =15        21
ESPCMD_VERSION =02        2
ESPCMD_WRITE   =13        19
FAC            =38E7      14567
FACHO          =38E6      14566
FACLO          =38E4      14564
FACMO          =38E5      14565
FBUFFR         =38E8      14568
FCERR          = 697      1687
FCOUNT         =03        3
FDIVA          =3818      14360
FDIVB          =3814      14356
FDIVC          =3810      14352
FDIVG          =381B      14363
FILNAF         =3857      14423
FILNAM         =3851      14417
FLGINP         =38CD      14541
FN_HEX          22DA      8922
FN_IN           2284      8836
FN_JOY          2298      8856
FO_ACCMODE     =03        3
FO_APPEND      =04        4
FO_CREATE      =08        8
FO_EXCL        =20        32
FO_RDONLY      =00        0
FO_RDWR        =02        2
FO_TRUNC       =10        16
FO_WRONLY      =01        1
FPSTR          =38E9      14569
FRCINT         = 682      1666
FRETOP         =38C1      14529
FRMEVL         = 985      2437
FRMNUM         = 972      2418
GETBYT         = B54      2900
HOOK           =3806      14342
INITFF         = 153      339
INSYNC         =385D      14429
INT2STR        =1679      5753
IO_BANK0       =F0        240
IO_BANK1       =F1        241
IO_BANK2       =F2        242
IO_BANK3       =F3        243
IO_CASSETTE    =FC        252
IO_CPM         =FD        253
IO_ESPCTRL     =F4        244
IO_ESPDATA     =F5        245
IO_IRQMASK     =EE        238
IO_IRQSTAT     =EF        239
IO_KEYBOARD    =FF        255
IO_PRINTER     =FE        254
IO_PSG1ADDR    =F7        247
IO_PSG1DATA    =F6        246
IO_PSG2ADDR    =F9        249
IO_PSG2DATA    =F8        248
IO_SCRAMBLE    =FF        255
IO_SYSCTRL     =FB        251
IO_VCTRL       =E0        224
IO_VIRQLINE    =ED        237
IO_VLINE       =EC        236
IO_VPALDATA    =EB        235
IO_VPALSEL     =EA        234
IO_VSCRX_H     =E2        226
IO_VSCRX_L     =E1        225
IO_VSCRY       =E3        227
IO_VSPRATTR    =E9        233
IO_VSPRIDX     =E8        232
IO_VSPRSEL     =E4        228
IO_VSPRX_H     =E6        230
IO_VSPRX_L     =E5        229
IO_VSPRY       =E7        231
IO_VSYNC       =FD        253
JMPINI         =1FE1      8161
KCOUNT         =380F      14351
LABBCK         = A49      2633
LASTFF         =3809      14345
LEN1           = FF7      4087
LINLEN         =3848      14408
LPTPOS         =3846      14406
LSTX           =380E      14350
MEMSIZ         =38AD      14509
MOERR          = 3D6      982
NEWSTT         = 62C      1580
OLDLIN         =38D2      14546
OLDTXT         =38D4      14548
OMERR          = BB7      2999
PARCHK         = A37      2615
PATHBUF        =BF01      48897
PATHLEN        =BF00      48896
PRNTIT         =1FF2      8178
PRTFLG         =3847      14407
PTRGET         =10D1      4305
READY          = 402      1026
RESET          =89        137
RESHO          =38F6      14582
RESLO          =38F8      14584
RESMO          =38F7      14583
RESPTR         =380B      14347
RESSRC         = 5A8      1448
RNDCNT         =381F      14367
RNDTAB         =3821      14369
RNDX           =3841      14401
RUBSW          =384A      14410
RUNC           = BCB      3019
RUNC2          = 6DB      1755
SAVSTK         =38F9      14585
SAVTXT         =38CE      14542
SCREEN         =3000      12288
SCRTCH         = BBE      3006
SNERR          = 3C4      964
SNGFLT         = B36      2870
STKINI         = BE5      3045
STREND         =38DA      14554
STROUT         = E9D      3741
ST_CALL         2314      8980
ST_CD           23B7      9143
ST_CLS          2208      8712
ST_DEL          23A6      9126
ST_DIR          23F6      9206
ST_LOAD         231C      8988
ST_LOCATE       221C      8732
ST_MKDIR        23E5      9189
ST_OUT          220C      8716
ST_PSG          225B      8795
ST_SAVE         236B      9067
ST_reserved     2207      8711
SUBFLG         =38CB      14539
TBLCMDS         213C      8508
TBLFEND         2197      8599
TBLFNJP         2191      8593
TBLJEND         2191      8593
TBLJMPS         2177      8567
TEMP8          =38C5      14533
TEMPPT         =38AF      14511
TEMPST         =38B1      14513
TENP2          =38D0      14544
TENP3          =38C3      14531
TMPBUF         =BFEC      49132
TOPMEM         =384B      14411
TTYCHR         =1D72      7538
TTYFIS         =1DE7      7655
TTYOUT         =1D94      7572
TTYPOS         =3800      14336
TXTTAB         =384F      14415
USFLG          =38CC      14540
USRADD         =3804      14340
USRPOK         =3803      14339
VALTYP         =38AB      14507
VARNAM         =38DE      14558
VARPNT         =38E0      14560
VARTAB         =38D6      14550
VCTRL_MODE_BM  =04        4
VCTRL_MODE_OFF =00        0
VCTRL_MODE_TILE=02        2
VCTRL_SPR_EN   =08        8
VCTRL_TEXT_EN  =01        1
VCTRL_TEXT_PRIO=10        16
WRMCON         =1A40      6720
XINIT          =E010      57360
_coldboot$sdbasic.asm 207F      8319
_hook_handlers$sdbasic.asm 2130      8496
_hook_idxs$sdbasic.asm 212B      8491
_reset$sdbasic.asm 2009      8201
_start_cart$sdbasic.asm 20EB      8427
check_sync_bytes 27A7      10151
descramble_rom  2911      10513
do_jump         211D      8477
err_bad_file    25F5      9717
esp_close_all   2700      9984
esp_cmd         2607      9735
esp_create      2718      10008
esp_error       256F      9583
esp_get_byte    261A      9754
esp_get_result  26F8      9976
esp_open        2708      9992
esp_read_bytes  2728      10024
esp_seek        2782      10114
esp_send_byte   2623      9763
esp_send_bytes  2753      10067
esp_send_pathbuf 26EB      9963
esp_write_bytes 2762      10082
exec_next_statement 21D0      8656
execute_function 2197      8599
firstf         =E1        225
get_arg         279F      10143
get_array_argument 2344      9028
get_next        279E      10142
get_string_parameter 26CC      9932
hook_exit       2127      8487
hook_handler    2109      8457
init_basic_program 2687      9863
init_charram    205E      8286
key_tables      2F00      12032
keyword_to_token 21AB      8619
lastf          =E3        227
load_basic_program 280B      10251
load_binary     27CB      10187
load_caq_array  27DD      10205
load_rom        28EE      10478
out_number_2digits 262E      9774
out_number_4digits 264D      9805
run_cmd         21EC      8684
run_file        28BD      10429
save_basic_program 2848      10312
save_binary     28AA      10410
save_caq_array  287F      10367
sync_bytes      283B      10299
to_upper        2940      10560
token_to_keyword 21BE      8638
